<docs>
<doc name="T:PeterO.ArrayWriter">
<summary>An array of bytes that grows as needed.
    </summary>
</doc>
<doc name="M:PeterO.ArrayWriter.#ctor">
<summary>Initializes a new instance of the <see cref='T:PeterO.ArrayWriter'/> class with a default buffer size.
    </summary>
</doc>
<doc name="M:PeterO.ArrayWriter.#ctor(System.Int32)">
<summary>Initializes a new instance of the <see cref='T:PeterO.ArrayWriter'/> class with the given initial buffer size.
    </summary>
    <param name='initialSize'>The parameter
      <paramref name='initialSize'/>
       is a 32-bit signed integer.
    </param>
</doc>
<doc name="M:PeterO.ArrayWriter.Clear">
<summary>Offers a fast way to reset the length of the array writer's data to 0.
    </summary>
</doc>
<doc name="M:PeterO.ArrayWriter.ToArray">
<summary>Generates an array of all bytes written so far to it.
    </summary>
    <returns>A byte array.
    </returns>
</doc>
<doc name="M:PeterO.ArrayWriter.Write(System.Byte[],System.Int32,System.Int32)">
<summary>Writes a series of bytes to the array.
    </summary>
    <param name='src'>Byte array containing the data to write.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of
      <paramref name='src'/>
       begins.
    </param>
    <param name='length'>The number of elements in the desired portion of
      <paramref name='src'/>
       (but not more than
      <paramref name='src'/>
       's length).
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='src'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='src'/>
       's length, or
      <paramref name='src'/>
       ' s length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
</doc>
<doc name="M:PeterO.ArrayWriter.WriteByte(System.Int32)">
<summary>Writes an 8-bit byte to the array.
    </summary>
    <param name='byteValue'>An integer containing the byte to write. Only the lower 8 bits of this
      value will be used.
    </param>
</doc>
<doc name="T:PeterO.BigInteger">
<summary><para><b>This class is largely obsolete. It will be replaced by a new version
          of this class in a different namespace/package and library, called
          <c>PeterO.Numbers.EInteger</c>
           in the
          <a href='https://www.nuget.org/packages/PeterO.Numbers'>
            <c>PeterO.Numbers</c>
          </a>
           library (in .NET), or
          <c>com.upokecenter.numbers.EInteger</c>
           in the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c>
          </a>
           artifact (in Java). This new class can be used in the
          <c>CBORObject.FromObject(object)</c>
           method (by including the new library in your code, among other
          things).</b>
      </para>
       An arbitrary-precision integer.
      <para><b>Thread safety:</b>
         Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        value are interchangeable, but they should be compared using the
        "Equals" method rather than the "==" operator.
      </para>
    </summary>
</doc>
<doc name="M:PeterO.BigInteger.CompareTo(PeterO.BigInteger)">

            <summary>Compares this value to another.
    </summary><param name='other'>The parameter
      <paramref name='other'/>
       is an arbitrary-precision integer.
    </param><returns>Less than 0 if this value is less than, 0 if equal to, or greater than 0
      if greater than the other value.
    </returns>

</doc>
<doc name="M:PeterO.BigInteger.Equals(PeterO.BigInteger)">

            <summary>Returns whether this number's value equals another number's value.
    </summary><param name='other'>An arbitrary-precision integer.
    </param><returns><c>true</c>
       if this number's value equals another number's value; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.BigInteger.Equals(System.Object)">

            <inheritdoc/><summary>Determines whether this object and another object are equal.
    </summary><param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param><returns><c>true</c>
       if this object and another object are equal; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.BigInteger.GetHashCode">

            <summary>Returns the hash code for this instance. No application or process IDs
      are used in the hash code calculation.
    </summary><returns>A 32-bit signed integer.
    </returns>

</doc>
<doc name="F:PeterO.BigInteger.ONE">

            <summary>BigInteger for the number one.
    </summary>

</doc>
<doc name="P:PeterO.BigInteger.One">

            <summary>Gets the arbitrary-precision integer for one.
    </summary><value>The arbitrary-precision integer for one.
    </value>

</doc>
<doc name="M:PeterO.BigInteger.ToString">

            <summary>Converts this object to a text string in base 10.
    </summary><returns>A string representation of this object. If negative, the string will
      begin with a minus sign ("-", U+002D). The string will use the basic
      digits 0 to 9 (U+0030 to U+0039).
    </returns>

</doc>
<doc name="P:PeterO.BigInteger.Zero">

            <summary>Gets the arbitrary-precision integer for zero.
    </summary><value>The arbitrary-precision integer for zero.
    </value>

</doc>
<doc name="M:PeterO.BigInteger.bitLength">

            <summary>Finds the minimum number of bits needed to represent this object's value,
      except for its sign. If the value is negative, finds the number of bits in
      a value equal to this object's absolute value minus 1.
    </summary><returns>The number of bits in this object's value. Returns 0 if this object's
      value is 0 or negative 1.
    </returns>

</doc>
<doc name="M:PeterO.BigInteger.fromBytes(System.Byte[],System.Boolean)">

            <summary>Initializes an arbitrary-precision integer from an array of bytes.
    </summary><param name='bytes'>A byte array consisting of the two's-complement form of the
      arbitrary-precision integer to create. The last byte contains the lowest
      8-bits, the next-to-last contains the next lowest 8 bits, and so on. To
      encode negative numbers, take the absolute value of the number, subtract
      by 1, encode the number into bytes, XOR each byte, and if the
      most-significant bit of the first byte isn't set, add an additional byte
      at the start with the value 255. For little-endian, the byte order is
      reversed from the byte order just discussed.
    </param><param name='littleEndian'>If true, the byte order is little-endian, or least-significant-byte
      first. If false, the byte order is big-endian, or most-significant-byte
      first.
    </param><returns>An arbitrary-precision integer. Returns 0 if the byte array's length is
      0.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bytes'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.BigInteger.fromRadixString(System.String,System.Int32)">

            <summary>Converts a string to an arbitrary-precision integer.
    </summary><param name='str'>A text string. The string must contain only characters allowed by the
      given radix, except that it may start with a minus sign ("-", U+002D) to
      indicate a negative number. The string is not allowed to contain white
      space characters, including spaces.
    </param><param name='radix'>A base from 2 to 36. Depending on the radix, the string can use the basic
      digits 0 to 9 (U+0030 to U+0039) and then the basic letters A to Z (U+0041
      to U+005A). For example, 0-9 in radix 10, and 0-9, then A-F in radix 16.
    </param><returns>An arbitrary-precision integer with the same value as given in the
      string.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception><exception cref='T:System.ArgumentException'>The parameter
      <paramref name='radix'/>
       is less than 2 or greater than 36.
    </exception><exception cref='T:System.FormatException'>The string is empty or in an invalid format.
    </exception>

</doc>
<doc name="M:PeterO.BigInteger.fromString(System.String)">

            <summary>Converts a string to an arbitrary-precision integer.
    </summary><param name='str'>A text string. The string must contain only basic digits 0 to 9 (U+0030
      to U+0039), except that it may start with a minus sign ("-", U+002D) to
      indicate a negative number. The string is not allowed to contain white
      space characters, including spaces.
    </param><returns>An arbitrary-precision integer with the same value as given in the
      string.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception><exception cref='T:System.FormatException'>The parameter
      <paramref name='str'/>
       is in an invalid format.
    </exception>

</doc>
<doc name="M:PeterO.BigInteger.toBytes(System.Boolean)">

            <summary>Returns a byte array of this object's value. The byte array will take the
      form of the number's two' s-complement representation, using the fewest
      bytes necessary to represent its value unambiguously. If this value is
      negative, the bits that appear "before" the most significant bit of the
      number will be all ones.
    </summary><param name='littleEndian'>If true, the least significant bits will appear first.
    </param><returns>A byte array. If this value is 0, returns a byte array with the single
      element 0.
    </returns>

</doc>
<doc name="M:PeterO.BigInteger.toRadixString(System.Int32)">

            <summary>Generates a string representing the value of this object, in the given
      radix.
    </summary><param name='radix'>A radix from 2 through 36. For example, to generate a hexadecimal
      (base-16) string, specify 16. To generate a decimal (base-10) string,
      specify 10.
    </param><returns>A string representing the value of this object. If this value is 0,
      returns "0". If negative, the string will begin with a hyphen/minus ("-").
      Depending on the radix, the string will use the basic digits 0 to 9
      (U+0030 to U+0039) and then the basic letters A to Z (U+0041 to U+005A).
      For example, 0-9 in radix 10, and 0-9, then A-F in radix 16.
    </returns><exception cref='T:System.ArgumentException'>The parameter "index" is less than 0, "endIndex" is less than 0, or
      either is greater than the string's length, or "endIndex" is less than
      "index" ; or radix is less than 2 or greater than 36.
    </exception>

</doc>
<doc name="M:PeterO.BigInteger.valueOf(System.Int64)">

            <summary>Converts a 64-bit signed integer to a big integer.
    </summary><param name='longerValue'>The parameter
      <paramref name='longerValue'/>
       is a 64-bit signed integer.
    </param><returns>An arbitrary-precision integer with the same value as the 64-bit number.
    </returns>

</doc>
<doc name="T:CBORDataUtilities">

            <summary>Contains methods useful for reading and writing data, with a focus on
      CBOR.
    </summary>

</doc>
<doc name="M:CBORDataUtilities.ParseJSONNumber(System.String)">

            <summary>Parses a number whose format follows the JSON specification. See
      #ParseJSONNumber(String, integersOnly, parseOnly) for more information.
    </summary><param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param><returns>A CBOR object that represents the parsed number. Returns positive zero if
      the number is a zero that starts with a minus sign (such as "-0" or
      "-0.0"). Returns null if the parsing fails, including if the string is
      null or empty.
    </returns>

</doc>
<doc name="M:CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean)">

            <summary>Parses a number whose format follows the JSON specification (RFC 8259).
      Roughly speaking, a valid number consists of an optional minus sign, one
      or more basic digits (starting with 1 to 9 unless the only digit is 0), an
      optional decimal point (".", full stop) with one or more basic digits, and
      an optional letter E or e with an optional plus or minus sign and one or
      more basic digits (the exponent).
    </summary><param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param><param name='integersOnly'>If true, no decimal points or exponents are allowed in the string.
    </param><param name='positiveOnly'>If true, only positive numbers are allowed (the leading minus is
      disallowed).
    </param><returns>A CBOR object that represents the parsed number. Returns positive zero if
      the number is a zero that starts with a minus sign (such as "-0" or
      "-0.0"). Returns null if the parsing fails, including if the string is
      null or empty.
    </returns>

</doc>
<doc name="M:CBORDataUtilities.ParseJSONNumber(System.String,System.Boolean,System.Boolean,System.Boolean)">

            <summary>Parses a number whose format follows the JSON specification (RFC 8259).
      Roughly speaking, a valid number consists of an optional minus sign, one
      or more basic digits (starting with 1 to 9 unless the only digit is 0), an
      optional decimal point (".", full stop) with one or more basic digits, and
      an optional letter E or e with an optional plus or minus sign and one or
      more basic digits (the exponent).
    </summary><param name='str'>A string to parse. The string is not allowed to contain white space
      characters, including spaces.
    </param><param name='integersOnly'>If true, no decimal points or exponents are allowed in the string.
    </param><param name='positiveOnly'>If true, only positive numbers are allowed (the leading minus is
      disallowed).
    </param><param name='preserveNegativeZero'>If true, returns positive zero if the number is a zero that starts with a
      minus sign (such as "-0" or "-0.0"). Otherwise, returns negative zero in
      this case.
    </param><returns>A CBOR object that represents the parsed number. Returns null if the
      parsing fails, including if the string is null or empty.
    </returns>

</doc>
<doc name="T:CBOREncodeOptions">

            <summary>Specifies options for encoding and decoding CBOR objects.
    </summary>

</doc>
<doc name="M:CBOREncodeOptions.#ctor">

            <summary>Initializes a new instance of the <see cref='T:CBOREncodeOptions'/> class.
    </summary>

</doc>
<doc name="M:CBOREncodeOptions.#ctor(System.Boolean,System.Boolean)">

            <summary>Initializes a new instance of the <see cref='T:CBOREncodeOptions'/> class.
    </summary><param name='useIndefLengthStrings'>A value indicating whether to always encode strings with a
      definite-length encoding.
    </param><param name='allowDuplicateKeys'>A value indicating whether to disallow duplicate keys when reading CBOR
      objects from a data stream.
    </param>

</doc>
<doc name="M:CBOREncodeOptions.#ctor(System.Boolean,System.Boolean,System.Boolean)">

            <summary>Initializes a new instance of the <see cref='T:CBOREncodeOptions'/> class.</summary><param name='useIndefLengthStrings'>A value indicating whether to
            always encode strings with a definite-length encoding.</param><param name='allowDuplicateKeys'>A value indicating whether to
            disallow duplicate keys when reading CBOR objects from a data
            stream.</param><param name='ctap2Canonical'>Either <c>true</c> or <c>false</c>
            .</param>

</doc>
<doc name="P:CBOREncodeOptions.AllowDuplicateKeys">

            <summary>Gets a value indicating whether to disallow duplicate keys when reading
      CBOR objects from a data stream. Used only when decoding CBOR objects.
    </summary><value>A value indicating whether to disallow duplicate keys when reading CBOR
      objects from a data stream.
    </value>

</doc>
<doc name="M:CBOREncodeOptions.And(CBOREncodeOptions)">

            <summary>Returns an options object containing the flags shared by this and another
      options object.
    </summary><param name='o'>The parameter
      <paramref name='o'/>
       is a CBOREncodeOptions object.
    </param><returns>A CBOREncodeOptions object.
    </returns>

</doc>
<doc name="P:CBOREncodeOptions.Ctap2Canonical">

            <summary>Gets a value indicating whether CBOR objects are written
            out using the CTAP2 canonical CBOR encoding form. In this form,
            CBOR tags are not used, map keys are written out in a canonical
            order, and non-integer numbers and integers 2^63 or greater are
            written as 64-bit binary floating-point numbers.</summary><value><c>true</c> if CBOR objects are written out using the CTAP2
            canonical CBOR encoding form; otherwise, <c>false</c>.. In this
            form, CBOR tags are not used, map keys are written out in a
            canonical order, and non-integer numbers and integers 2^63 or
            greater are written as 64-bit binary floating-point
            numbers.</value>

</doc>
<doc name="F:CBOREncodeOptions.Default">

            <summary>Default options for CBOR objects. Disallow duplicate keys, and always
      encode strings using definite-length encoding. These are recommended
      settings for the options that may be adopted by certain CBORObject methods
      in the next major version.
    </summary>

</doc>
<doc name="F:CBOREncodeOptions.NoDuplicateKeys">

            <summary>Disallow duplicate keys when reading CBOR objects from a data stream.
      Used only when decoding CBOR objects. Value: 2.
    </summary>

</doc>
<doc name="F:CBOREncodeOptions.NoIndefLengthStrings">

            <summary>Always encode strings with a definite-length encoding. Used only when
      encoding CBOR objects. Value: 1.
    </summary>

</doc>
<doc name="F:CBOREncodeOptions.None">

            <summary>No special options for encoding/decoding. Value: 0.
    </summary>

</doc>
<doc name="M:CBOREncodeOptions.Or(CBOREncodeOptions)">

            <summary>Returns an options object containing the combined flags of this and
      another options object.
    </summary><param name='o'>The parameter
      <paramref name='o'/>
       is a CBOREncodeOptions object.
    </param><returns>A new CBOREncodeOptions object.
    </returns>

</doc>
<doc name="P:CBOREncodeOptions.UseIndefLengthStrings">

            <summary>Gets a value indicating whether to always encode strings with a
      definite-length encoding.
    </summary><value>A value indicating whether to always encode strings with a
      definite-length encoding.
    </value>

</doc>
<doc name="P:CBOREncodeOptions.Value">
<summary>Gets this options object's value.
    </summary>
    <value>This options object&apos;s value.
    </value>
</doc>
<doc name="T:CBORException">

            <summary>Exception thrown for errors involving CBOR data.
    </summary>

</doc>
<doc name="M:CBORException.#ctor">

            <summary>Initializes a new instance of the <see cref='T:CBORException'/> class.
    </summary>

</doc>
<doc name="M:CBORException.#ctor(System.String)">

            <summary>Initializes a new instance of the <see cref='T:CBORException'/> class.
    </summary><param name='message'>The parameter
      <paramref name='message'/>
       is a text string.
    </param>

</doc>
<doc name="M:CBORException.#ctor(System.String,System.Exception)">

            <summary>Initializes a new instance of the <see cref='T:CBORException'/> class. Uses the given message and inner exception.
    </summary><param name='message'>The parameter
      <paramref name='message'/>
       is a text string.
    </param><param name='innerException'>The parameter
      <paramref name='innerException'/>
       is an Exception object.
    </param>

</doc>
<doc name="M:CBORMapper.AddConverter``1(System.Type,ICBORConverter{``0})">
<summary>Registers an object that converts objects of a given type to CBOR objects
      (called a CBOR converter).
    </summary>
    <param name='type'>A Type object specifying the type that the converter converts to CBOR
      objects.
    </param>
    <param name='converter'>The parameter
      <paramref name='converter'/>
      A CBOR converter.
    </param>
    <typeparam name='T'>
      Must be the same as the "type" parameter.
    </typeparam>
    <returns>This object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='type'/>
       or
      <paramref name='converter'/>
       is null.
    </exception>
    <exception cref='T:System.ArgumentException'>"Converter doesn't contain a proper ToCBORObject method".
    </exception>
</doc>
<doc name="T:CBORObject">

            <summary><para>Represents an object in Concise Binary Object Representation (CBOR) and
      contains methods for reading and writing CBOR data. CBOR is defined in RFC
      7049.</para>
      <para><b>Converting CBOR objects</b>
      </para>
      <para>There are many ways to get a CBOR object, including from bytes,
        objects, streams and JSON, as described below.
      </para>
      <para><b>To and from byte arrays:</b>
         The CBORObject.DecodeFromBytes method converts a byte array in CBOR
        format to a CBOR object. The EncodeToBytes method converts a CBOR object
        to its corresponding byte array in CBOR format.
      </para>
      <para><b>To and from data streams:</b>
        The CBORObject.Write methods write many kinds of objects to a data
        stream, including numbers, CBOR objects, strings, and arrays of numbers
        and strings. The CBORObject.Read method reads a CBOR object from a data
        stream.
      </para>
      <para><b>To and from other objects:</b>
        The <c>CBORObject.FromObject</c> method converts many kinds of objects to a CBOR object, including numbers, strings, and arrays and maps of numbers
        and strings. Methods like AsDouble, AsByte, and AsString convert a CBOR
        object to different types of object.  The <c>CBORObject.ToObject</c> method converts a CBOR object to an object of a given type; for example, a CBOR array to a native <c>List</c> (or <c>ArrayList</c> in Java), or a CBOR integer to an <c>int</c> or <c>long</c>.
      </para>
      <para><b>To and from JSON:</b>
        This class also doubles as a reader and writer of JavaScript Object
        Notation (JSON). The CBORObject.FromJSONString method converts JSON to a
        CBOR object, and the ToJSONString method converts a CBOR object to a
        JSON string.
      </para>
      <para>In addition, the CBORObject.WriteJSON method writes many kinds of
        objects as JSON to a data stream, including numbers, CBOR objects,
        strings, and arrays of numbers and strings. The CBORObject.Read method
        reads a CBOR object from a JSON data stream.
      </para>
      <para><b>Comparison Considerations:</b>
      </para>
      <para>Instances of CBORObject should not be compared for equality using the
        "==" operator; it's possible to create two CBOR objects with the same
        value but not the same reference. (The "==" operator might only check if
        each side of the operator is the same instance.)
      </para>
      <para>This class's natural ordering (under the CompareTo method) is not
        consistent with the Equals method. This means that two values that
        compare as equal under the CompareTo method might not be equal under the
        Equals method. This is important to consider especially if an
        application wants to compare numbers, since the CBOR number type
        supports numbers of different formats, such as big integers, rational
        numbers, and arbitrary-precision decimal numbers.
      </para>
      <para>Another consideration is that two values that are otherwise equal may
        have different tags. To strip the tags from a CBOR object before
        comparing, use the
        <c>Untag</c>
         method.
      </para>
      <para>To compare two numbers, the CompareToIgnoreTags or CompareTo method
        should be used. Which method to use depends on whether two equal values
        should still be considered equal if they have different tags.
      </para>
      <para>Although this class is inconsistent with the Equals method, it is safe
        to use CBORObject instances as hash keys as long as all of the keys are
        untagged text strings (which means GetTags returns an empty array and
        the Type property, or "getType()" in Java, returns TextString). This is
        because the natural ordering of these instances is consistent with the
        Equals method.
      </para>
      <para><b>Thread Safety:</b>
      </para>
      <para>CBOR objects that are numbers, "simple values", and text strings are
        immutable (their values can't be changed), so they are inherently safe
        for use by multiple threads.
      </para>
      <para>CBOR objects that are arrays, maps, and byte strings are mutable, but
        this class doesn't attempt to synchronize reads and writes to those
        objects by multiple threads, so those objects are not thread safe
        without such synchronization.
      </para>
      <para>One kind of CBOR object is called a map, or a list of key-value pairs.
        Keys can be any kind of CBOR object, including numbers, strings, arrays,
        and maps. However, text strings are the most suitable to use as keys;
        other kinds of CBOR object are much better used as map values instead,
        keeping in mind that some of them are not thread safe without
        synchronizing reads and writes to them.
      </para>
      <para>To find the type of a CBOR object, call its Type property (or
        "getType()" in Java). The return value can be Number, Boolean,
        SimpleValue, or TextString for immutable CBOR objects, and Array, Map,
        or ByteString for mutable CBOR objects.
      </para>
      <para><b>Nesting Depth:</b>
      </para>
      <para>The DecodeFromBytes and Read methods can only read objects with a
        limited maximum depth of arrays and maps nested within other arrays and
        maps. The code sets this maximum depth to 500 (allowing more than enough
        nesting for most purposes), but it's possible that stack overflows in
        some runtimes might lower the effective maximum nesting depth. When the
        nesting depth goes above 500, the DecodeFromBytes and Read methods throw
        a CBORException.
      </para>
      <para>The ReadJSON and FromJSONString methods currently have nesting depths
        of 1000.
      </para>
    </summary>

</doc>
<doc name="M:CBORObject.Abs">

            <summary>Gets this object's absolute value.</summary><returns>This object's absolute without its negative
            sign.</returns><exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type.</exception>

</doc>
<doc name="M:CBORObject.Add(CBORObject)">

            <summary><para>Adds a new object to the end of this array. (Used to
            throw ArgumentNullException on a null reference, but now converts
            the null reference to CBORObject.Null, for convenience with the
            Object overload of this method).</para>
             <para>NOTE: This method
            can't be used to add a tag to an existing CBOR object. To create a
            CBOR object with a given tag, call the
            <c>CBORObject.FromObjectAndTag</c>
             method and pass the CBOR object
            and the desired tag number to that method.</para>
             </summary><param name='obj'>The parameter <paramref name='obj'/> is a CBOR
            object.</param><returns>This instance.</returns><exception cref='T:System.InvalidOperationException'>This object is
            not an array.</exception><example><para>The following example creates a CBOR array and adds several
            CBOR objects, one of which has a custom CBOR tag, to that array.
            Note the chaining behavior made possible by this method.</para>
            <code>CBORObject obj = CBORObject.NewArray()
            .Add(CBORObject.False)
            .Add(CBORObject.FromObject(5))
            .Add(CBORObject.FromObject("text string"))
            .Add(CBORObject.FromObjectAndTag(9999, 1));
            </code>
            </example>

</doc>
<doc name="M:CBORObject.Add(System.Object)">

            <summary><para>Converts an object to a CBOR object and adds it to
            the end of this array.</para>
             <para>NOTE: This method can't be used
            to add a tag to an existing CBOR object. To create a CBOR object
            with a given tag, call the <c>CBORObject.FromObjectAndTag</c>
            method and pass the CBOR object and the desired tag number to that
            method.</para>
             </summary><param name='obj'>The parameter <paramref name='obj'/> is a CBOR
            object.</param><returns>This instance.</returns><exception cref='T:System.InvalidOperationException'>This object is
            not an array.</exception><exception cref='T:System.ArgumentException'>The type of <paramref name='obj'/> is not supported.</exception><example><para>The following example creates a CBOR array and adds several
            CBOR objects, one of which has a custom CBOR tag, to that array.
            Note the chaining behavior made possible by this method.</para>
            <code>CBORObject obj = CBORObject.NewArray()
            .Add(CBORObject.False)
            .Add(5)
            .Add("text string")
            .Add(CBORObject.FromObjectAndTag(9999, 1));
            </code>
            </example>

</doc>
<doc name="M:CBORObject.Add(System.Object,System.Object)">

            <summary><para>Adds a new key and its value to this CBOR map, or adds the
            value if the key doesn't exist.</para>
<para>NOTE: This method can't be used to add a tag to an existing CBOR object.  To create a CBOR object with a given tag, call the <c>CBORObject.FromObjectAndTag</c> method and pass the CBOR object and the desired tag number to that method.</para></summary><param name='key'>An object representing the key, which will be
            converted to a CBORObject. Can be null, in which case this value is
            converted to CBORObject.Null.</param><param name='valueOb'>An object representing the value, which will
            be converted to a CBORObject. Can be null, in which case this value
            is converted to CBORObject.Null.</param><returns>This instance.</returns><exception cref='T:System.ArgumentException'>The parameter
            <paramref name='key'/> already exists in this map.</exception><exception cref='T:System.InvalidOperationException'>This object is
            not a map.</exception><exception cref='T:System.ArgumentException'>The parameter
            <paramref name='key'/> or <paramref name='valueOb'/> has an
            unsupported type.</exception>

</doc>
<doc name="M:CBORObject.AddConverter``1(System.Type,ICBORConverter{``0})">

            <summary>Registers an object that converts objects of a given type
             to CBOR objects (called a CBOR converter).</summary><param name='type'>A Type object specifying the type that the
             converter converts to CBOR objects.</param><param name='converter'>The parameter <paramref name='converter'/>
             is an ICBORConverter object.</param><typeparam name='T'>Must be the same as the "type"
             parameter.</typeparam><exception cref='T:System.ArgumentNullException'>The parameter
             <paramref name='type'/> or <paramref name='converter'/> is
             null.</exception><exception cref='T:System.ArgumentException'>"Converter doesn't contain a
             proper ToCBORObject method".</exception>

</doc>
<doc name="M:CBORObject.AddTagHandler(PeterO.BigInteger,ICBORTag)">

            <summary>Registers an object that validates CBOR objects with new
            tags.</summary><param name='bigintTag'>An arbitrary-precision integer.</param><param name='handler'>The parameter <paramref name='handler'/> is
            an ICBORTag object.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigintTag'/> or <paramref name='handler'/> is
            null.</exception><exception cref='T:System.ArgumentException'>The parameter
            <paramref name='bigintTag'/> is less than 0 or greater than
            (2^64-1).</exception>

</doc>
<doc name="M:CBORObject.AddTagHandler(PeterO.Numbers.EInteger,ICBORTag)">

            <summary>Registers an object that validates CBOR objects with new
            tags.</summary><param name='bigintTag'>An arbitrary-precision integer.</param><param name='handler'>The parameter <paramref name='handler'/> is
            an ICBORTag object.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigintTag'/> or <paramref name='handler'/> is
            null.</exception><exception cref='T:System.ArgumentException'>The parameter
            <paramref name='bigintTag'/> is less than 0 or greater than
            (2^64-1).</exception>

</doc>
<doc name="M:CBORObject.Addition(CBORObject,CBORObject)">

            <summary>Finds the sum of two CBOR numbers.</summary><param name='first'>The parameter <paramref name='first'/> is a
            CBOR object.</param><param name='second'>The parameter <paramref name='second'/> is a
            CBOR object.</param><returns>A CBORObject object.</returns><exception cref='T:System.ArgumentException'>Either or both
            operands are not numbers (as opposed to Not-a-Number,
            NaN).</exception>

</doc>
<doc name="M:CBORObject.AsBigInteger">

            <summary>Converts this object to an arbitrary-precision integer.
            Fractional values are truncated to an integer.</summary><returns>The closest big integer to this object.</returns><exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type, including if this object is
            CBORObject.Null.</exception><exception cref='T:System.OverflowException'>This object's value is
            infinity or not-a-number (NaN).</exception>

</doc>
<doc name="M:CBORObject.AsBoolean">

            <summary>Returns false if this object is False, Null, or Undefined;
      otherwise,true.
    </summary><returns>False if this object is False, Null, or Undefined; otherwise,true.
    </returns>

</doc>
<doc name="M:CBORObject.AsByte">

            <summary>Converts this object to a byte (0 to 255). Floating point
            values are truncated to an integer.</summary><returns>The closest byte-sized integer to this object.</returns><exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type.</exception><exception cref='T:System.OverflowException'>This object's value
            exceeds the range of a byte (would be less than 0 or greater than
            255 when truncated to an integer).</exception>

</doc>
<doc name="M:CBORObject.AsDecimal">

            <summary>Converts this object to a .NET decimal.
    </summary><returns>The closest big integer to this object.
    </returns><exception cref='T:System.InvalidOperationException'>This object's type is not a number type.
    </exception><exception cref='T:System.OverflowException'>This object's value exceeds the range of a .NET decimal.
    </exception>

</doc>
<doc name="M:CBORObject.AsDouble">

            <summary>Converts this object to a 64-bit floating point
            number.</summary><returns>The closest 64-bit floating point number to this object.
            The return value can be positive infinity or negative infinity if
            this value exceeds the range of a 64-bit floating point
            number.</returns><exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type.</exception>

</doc>
<doc name="M:CBORObject.AsEDecimal">

            <summary>Converts this object to a decimal number.</summary><returns>A decimal number for this object's value. If this object
            is a rational number with a nonterminating decimal expansion,
            returns a decimal number rounded to 34 digits.</returns><exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type, including if this object is
            CBORObject.Null.</exception>

</doc>
<doc name="M:CBORObject.AsEFloat">

            <summary>Converts this object to an arbitrary-precision binary
            floating point number.</summary><returns>An arbitrary-precision binary floating point number for
            this object's value. Note that if this object is a decimal number
            with a fractional part, the conversion may lose information
            depending on the number. If this object is a rational number with a
            nonterminating binary expansion, returns a binary floating-point
            number rounded to 113 bits.</returns><exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type, including if this object is
            CBORObject.Null.</exception>

</doc>
<doc name="M:CBORObject.AsEInteger">

            <summary>Converts this object to an arbitrary-precision integer.
            Fractional values are truncated to an integer.</summary><returns>The closest big integer to this object.</returns><exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type, including if this object is
            CBORObject.Null.</exception><exception cref='T:System.OverflowException'>This object's value is
            infinity or not-a-number (NaN).</exception>

</doc>
<doc name="M:CBORObject.AsERational">

            <summary>Converts this object to a rational number.</summary><returns>A rational number for this object's value.</returns><exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type, including if this object is
            CBORObject.Null.</exception>

</doc>
<doc name="M:CBORObject.AsExtendedDecimal">

            <summary>Converts this object to a decimal number.</summary><returns>A decimal number for this object's value. If this object
            is a rational number with a nonterminating decimal expansion,
            returns a decimal number rounded to 34 digits.</returns><exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type, including if this object is
            CBORObject.Null.</exception>

</doc>
<doc name="M:CBORObject.AsExtendedFloat">

            <summary>Converts this object to an arbitrary-precision binary
            floating point number.</summary><returns>An arbitrary-precision binary floating point number for
            this object's value. Note that if this object is a decimal number
            with a fractional part, the conversion may lose information
            depending on the number. If this object is a rational number with a
            nonterminating binary expansion, returns a binary floating-point
            number rounded to 113 bits.</returns><exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type, including if this object is
            CBORObject.Null.</exception>

</doc>
<doc name="M:CBORObject.AsExtendedRational">

            <summary>Converts this object to a rational number.</summary><returns>A rational number for this object's value.</returns><exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type, including if this object is
            CBORObject.Null.</exception>

</doc>
<doc name="M:CBORObject.AsInt16">

            <summary>Converts this object to a 16-bit signed integer. Floating
            point values are truncated to an integer.</summary><returns>The closest 16-bit signed integer to this
            object.</returns><exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type.</exception><exception cref='T:System.OverflowException'>This object's value
            exceeds the range of a 16-bit signed integer.</exception>

</doc>
<doc name="M:CBORObject.AsInt32">
<summary>Converts this object to a 32-bit signed integer. Non-integer number values
      are truncated to an integer. (NOTE: To determine whether this method call
      can succeed, call the
      <b>CanTruncatedIntFitInInt32</b>
       method before calling this method. Checking whether this object's type is

      <c>CBORType.Number</c>
       is not sufficient. See the example.).
    </summary>
    <returns>The closest 32-bit signed integer to this object.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type.
    </exception>
    <exception cref='T:System.OverflowException'>This object's value exceeds the range of a 32-bit signed integer.
    </exception>
    <example><para>The following example code (originally written in C# for the .NET
        Framework) shows a way to check whether a given CBOR object stores a
        32-bit signed integer before getting its value.
      </para>
      <code>CBORObject obj = CBORObject.FromInt32(99999); if&#x28;obj.IsIntegral
        &amp;&amp; obj.CanTruncatedIntFitInInt32&#x28;)) &#x7b; // Not an Int32;
        handle the error Console.WriteLine("Not a 32-bit integer."); &#x7d; else
        { Console.WriteLine("The value is " + obj.AsInt32()); }
      </code>
    </example>
</doc>
<doc name="M:CBORObject.AsInt64">
<summary>Converts this object to a 64-bit signed integer. Non-integer numbers are
      truncated to an integer. (NOTE: To determine whether this method call can
      succeed, call the
      <b>CanTruncatedIntFitInInt64</b>
       method before calling this method. Checking whether this object's type is

      <c>CBORType.Number</c>
       is not sufficient. See the example.).
    </summary>
    <returns>The closest 64-bit signed integer to this object.
    </returns>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type.
    </exception>
    <exception cref='T:System.OverflowException'>This object's value exceeds the range of a 64-bit signed integer.
    </exception>
    <example><para>The following example code (originally written in C# for the .NET
        Framework) shows a way to check whether a given CBOR object stores a
        64-bit signed integer before getting its value.
      </para>
      <code>CBORObject obj = CBORObject.FromInt64(99999); if&#x28;obj.IsIntegral
        &amp;&amp; obj.CanTruncatedIntFitInInt64&#x28;)) &#x7b; // Not an Int64;
        handle the error Console.WriteLine("Not a 64-bit integer."); &#x7d; else
        { Console.WriteLine("The value is " + obj.AsInt64()); }
      </code>
    </example>
</doc>
<doc name="M:CBORObject.AsSByte">

            <summary>Converts this object to an 8-bit signed integer.
    </summary><returns>An 8-bit signed integer.
    </returns>

</doc>
<doc name="M:CBORObject.AsSingle">

            <summary>Converts this object to a 32-bit floating point
            number.</summary><returns>The closest 32-bit floating point number to this object.
            The return value can be positive infinity or negative infinity if
            this object's value exceeds the range of a 32-bit floating point
            number.</returns><exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type.</exception>

</doc>
<doc name="M:CBORObject.AsString">

            <summary>Gets the value of this object as a text string.</summary><returns>Gets this object's string.</returns><exception cref='T:System.InvalidOperationException'>This object's
            type is not a string, including if this object is
            CBORObject.Null.</exception><example><para>The following example code (originally written in C# for the
            .NET Framework) shows an idiom for returning a string value if a
            CBOR object is a text string, or <c>null</c>
             if the CBOR object is
            a CBOR null.</para>
            <code>CBORObject obj = CBORObject.FromString("test");
            string str = obj.IsNull ? null : obj.AsString();
            </code>
            </example>

</doc>
<doc name="M:CBORObject.AsUInt16">

            <summary>Converts this object to a 16-bit unsigned integer. The return value will
      be truncated as necessary.
    </summary><returns>A 16-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>This object's value is outside the range of a 16-bit unsigned integer.
    </exception>

</doc>
<doc name="M:CBORObject.AsUInt32">

            <summary>Converts this object to a 32-bit unsigned integer. The return value will
      be truncated as necessary.
    </summary><returns>A 32-bit unsigned integer.
    </returns><exception cref='T:System.OverflowException'>This object's value is outside the range of a 32-bit unsigned integer.
    </exception>

</doc>
<doc name="M:CBORObject.AsUInt64">

            <summary>Converts this object to a 64-bit unsigned integer. Non-integer values are
      truncated to an integer.
    </summary><returns>The closest big integer to this object.
    </returns><exception cref='T:System.InvalidOperationException'>This object's type is not a number type.
    </exception><exception cref='T:System.OverflowException'>This object's value exceeds the range of a 64-bit unsigned integer.
    </exception>

</doc>
<doc name="M:CBORObject.CanFitInDouble">

            <summary>Returns whether this object's value can be converted to a 64-bit floating
      point number without its value being rounded to another numerical value.
    </summary><returns>Whether this object's value can be converted to a 64-bit floating point
      number without its value being rounded to another numerical value. Returns true if this is a
      not-a-number value, even if the value's diagnostic information can' t fit
      in a 64-bit floating point number.
    </returns>

</doc>
<doc name="M:CBORObject.CanFitInInt32">

            <summary>Returns whether this object's numerical value is an integer, is -(2^31) or
      greater, and is less than 2^31.
    </summary><returns><c>true</c>
       if this object's numerical value is an integer, is -(2^31) or greater, and
      is less than 2^31; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:CBORObject.CanFitInInt64">

            <summary>Returns whether this object's numerical value is an integer, is -(2^63) or
      greater, and is less than 2^63.
    </summary><returns><c>true</c>
       if this object's numerical value is an integer, is -(2^63) or greater, and
      is less than 2^63; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:CBORObject.CanFitInSingle">

            <summary>Returns whether this object's value can be converted to a 32-bit floating
      point number without its value being rounded to another numerical value.
    </summary><returns>Whether this object's value can be converted to a 32-bit floating point
      number without its value being rounded to another numerical value. Returns true if this is a
      not-a-number value, even if the value's diagnostic information can' t fit
      in a 32-bit floating point number.
    </returns>

</doc>
<doc name="M:CBORObject.CanTruncatedIntFitInInt32">

            <summary>Returns whether this object's value, truncated to an integer, would be
      -(2^31) or greater, and less than 2^31.
    </summary><returns><c>true</c>
       if this object's value, truncated to an integer, would be -(2^31) or
      greater, and less than 2^31; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:CBORObject.CanTruncatedIntFitInInt64">

            <summary>Returns whether this object's value, truncated to an integer, would be
      -(2^63) or greater, and less than 2^63.
    </summary><returns><c>true</c>
       if this object's value, truncated to an integer, would be -(2^63) or
      greater, and less than 2^63; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:CBORObject.Clear">
<summary>Removes all items from this CBOR array or all keys and values from this
      CBOR map.
    </summary>
    <exception cref='InvalidOperationException'>This object is not a CBOR array or CBOR map.
    </exception>
</doc>
<doc name="M:CBORObject.CompareTo(CBORObject)">

            <summary>Compares two CBOR objects.
             <para>In this implementation:</para>
             <list type=''>
             <item>The null pointer (null reference) is considered less than any
             other object.</item>
             <item>If either object is true, false, CBORObject.Null, or the
             undefined value, it is treated as less than the other value. If
             both objects have one of these four values, then undefined is less
             than CBORObject.Null, which is less than false, which is less than
             true.</item>
             <item>If both objects are numbers, their mathematical values are
             compared. Here, NaN (not-a-number) is considered greater than any
             number.</item>
             <item>If both objects are simple values other than true, false,
             CBORObject.Null, and the undefined value, the objects are compared
             according to their ordinal numbers.</item>
             <item>If both objects are arrays, each element is compared. If one
             array is shorter than the other and the other array begins with
             that array (for the purposes of comparison), the shorter array is
             considered less than the longer array.</item>
             <item>If both objects are strings, compares each string code-point
             by code-point, as though by the DataUtilities.CodePointCompare
             method.</item>
             <item>If both objects are maps, compares each map as though each
             were an array with the sorted keys of that map as the array's
             elements. If both maps have the same keys, their values are
             compared in the order of the sorted keys.</item>
             <item>If each object is a different type, then they are sorted by
             their type number, in the order given for the CBORType
             enumeration.</item>
             <item>If each object has different tags and both objects are
             otherwise equal under this method, each element is compared as
             though each were an array with that object's tags listed in order
             from outermost to innermost.</item></list>
             <para>This method is not consistent with the Equals
             method.</para></summary><param name='other'>A value to compare with.</param><returns>Less than 0, if this value is less than the other object;
             or 0, if both values are equal; or greater than 0, if this value is
             less than the other object or if the other object is
             null.</returns><exception cref='T:System.ArgumentException'>An internal error occurred.</exception>

</doc>
<doc name="M:CBORObject.CompareToIgnoreTags(CBORObject)">

            <summary>Compares this object and another CBOR object, ignoring the tags they
      have, if any. See the CompareTo method for more information on the
      comparison function.
    </summary><param name='other'>A value to compare with.
    </param><returns>Less than 0, if this value is less than the other object; or 0, if both
      values are equal; or greater than 0, if this value is less than the other
      object or if the other object is null.
    </returns>

</doc>
<doc name="M:CBORObject.ContainsKey(CBORObject)">

            <summary>Determines whether a value of the given key exists in this
            object.</summary><param name='key'>An object that serves as the key.</param><returns><c>true</c> if the given key is found, or false if the
            given key is not found or this object is not a map.</returns><exception cref='T:System.ArgumentNullException'>Key is null (as
            opposed to CBORObject.Null).</exception>

</doc>
<doc name="M:CBORObject.ContainsKey(System.String)">

            <summary>Determines whether a value of the given key exists in this
            object.</summary><param name='key'>A string that serves as the key.</param><returns><c>true</c> if the given key (as a CBOR object) is found,
            or false if the given key is not found or this object is not a
            map.</returns><exception cref='T:System.ArgumentNullException'>Key is
            null.</exception>

</doc>
<doc name="P:CBORObject.ConverterInfo.Converter">

            <summary>Gets or sets the ICBORConverter object.
    </summary><value>The ICBORConverter object.
    </value>

</doc>
<doc name="P:CBORObject.ConverterInfo.ToObject">
<summary>Gets or sets the converter's ToCBORObject method.
    </summary>
    <value>The converter&apos;s ToCBORObject method.
    </value>
</doc>
<doc name="P:CBORObject.Count">

            <summary>Gets the number of keys in this map, or the number of items in this
      array, or 0 if this item is neither an array nor a map.
    </summary><value>The number of keys in this map, or the number of items in this array, or
      0 if this item is neither an array nor a map.
    </value>

</doc>
<doc name="M:CBORObject.DecodeFromBytes(System.Byte[])">

            <summary><para><b>At the moment, use the overload of this method that takes
            a
            <see cref='T:CBOREncodeOptions'/> object. The object
            <c>CBOREncodeOptions.Default</c> contains recommended settings for
            CBOREncodeOptions, and those settings may be adopted by this
            overload (without a CBOREncodeOptions argument) in the next major
            version.</b></para>
            <para>Generates a CBOR object from an array of CBOR-encoded
            bytes.</para></summary><param name='data'>A byte array in which a single CBOR object is encoded.</param><returns>A CBOR object decoded from the given byte array.</returns><exception cref='T:CBORException'>There was an error in
            reading or parsing the data. This includes cases where not all of
            the byte array represents a CBOR object. This exception is also
            thrown if the parameter <paramref name='data'/> is
            empty.</exception><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='data'/> is null.</exception>

</doc>
<doc name="M:CBORObject.DecodeFromBytes(System.Byte[],CBOREncodeOptions)">
<summary>Generates a CBOR object from an array of CBOR-encoded bytes, using the
      given
      <c>CBOREncodeOptions</c>
       object to control the decoding process.
    </summary>
    <param name='data'>A byte array in which a single CBOR object is encoded.
    </param>
    <param name='options'>The parameter
      <paramref name='options'/>
       is a CBOREncodeOptions object.
    </param>
    <returns>A CBOR object decoded from the given byte array.
    </returns>
    <exception cref='T:CBORException'>There was an error in reading or parsing the data. This includes cases
      where not all of the byte array represents a CBOR object. This exception
      is also thrown if the parameter
      <paramref name='data'/>
       is empty.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='data'/>
       is null.
    </exception>
    <example><para>The following example (originally written in C# for the .NET version)
        implements a method that decodes a text string from a CBOR byte array.
        It's successful only if the CBOR object contains an untagged text
        string.
      </para>
      <code>private static String DecodeTextString&#x28;byte[] bytes)&#x7b;
        if&#x28;bytes == null)&#x7b; throw new
        ArgumentNullException&#x28;nameof(mapObj));&#x7d; if&#x28;bytes.Length
        == 0 || bytes[0]&lt;0x60 || bytes[0]&gt;0x7f)&#x7b;throw new
        CBORException&#x28;);&#x7d; return
        CBORObject.DecodeFromBytes&#x28;bytes,
        CBOREncodeOptions.Default).AsString&#x28;); &#x7d;
      </code>
    </example>
</doc>
<doc name="M:CBORObject.Divide(CBORObject,CBORObject)">

            <summary>Divides a CBORObject object by the value of a CBORObject object.
    </summary><param name='first'>The parameter
      <paramref name='first'/>
       is a CBOR object.
    </param><param name='second'>The parameter
      <paramref name='second'/>
       is a CBOR object.
    </param><returns>The quotient of the two objects.
    </returns>

</doc>
<doc name="M:CBORObject.EncodeToBytes">

            <summary><para><b>At the moment, use the overload of this method that takes a
          <see cref='T:CBOREncodeOptions'/>
           object. The object
          <c>CBOREncodeOptions.Default</c>
           contains recommended settings for CBOREncodeOptions, and those
          settings may be adopted by this overload (without a CBOREncodeOptions
          argument) in the next major version.</b>
      </para>
      <para>Writes the binary representation of this CBOR object and returns a byte
        array of that representation. If the CBOR object contains CBOR maps, or
        is a CBOR map itself, the keys to the map are written out to the byte
        array in an undefined order. The example code given in
        <see cref='M:CBORObject.WriteTo(System.IO.Stream)'/>
         can be used to write out certain keys of a CBOR map in a given order.
      </para>
    </summary><returns>A byte array in CBOR format.
    </returns>

</doc>
<doc name="M:CBORObject.EncodeToBytes(CBOREncodeOptions)">

            <summary>Writes the binary representation of this CBOR object and
            returns a byte array of that representation, using the specified
            options for encoding the object to CBOR format. If the CBOR object
            contains CBOR maps, or is a CBOR map itself, the keys to the map
            are written out to the byte array in an undefined order. The
            example code given in
            <see cref='M:CBORObject.WriteTo(System.IO.Stream)'/>
            can be used to write out certain keys of a CBOR map in a given
            order.</summary><param name='options'>Options for encoding the data to
            CBOR.</param><returns>A byte array in CBOR format.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='options'/> is null.</exception>

</doc>
<doc name="M:CBORObject.Equals(CBORObject)">

            <summary>Compares the equality of two CBOR objects. Not-a-number values can be
      considered equal by this method.
    </summary><param name='other'>The object to compare.
    </param><returns><c>true</c>
       if the objects are equal; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:CBORObject.Equals(System.Object)">

            <summary>Determines whether this object and another object are equal and have the
      same type. Not-a-number values can be considered equal by this method.
    </summary><param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param><returns><c>true</c>
       if the objects are equal; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="F:CBORObject.False">

            <summary>Represents the value false.
    </summary>

</doc>
<doc name="M:CBORObject.FromJSONString(System.String)">

            <summary><para><b>At the moment, use the overload of this method that takes
            a
            <see cref='T:CBOREncodeOptions'/> object. The object
            <c>CBOREncodeOptions.Default</c> contains recommended settings for
            CBOREncodeOptions, and those settings may be adopted by this
            overload (without a CBOREncodeOptions argument) in the next major
            version.</b></para>
            <para>Generates a CBOR object from a text string in JavaScript
            Object Notation (JSON) format.</para>
            <para>If a JSON object has the same key, only the last given value
            will be used for each duplicated key.</para></summary><param name='str'>A string in JSON format. The entire string must
            contain a single JSON object and not multiple objects. The string
            may not begin with a byte-order mark (U+FEFF).</param><returns>A CBORObject object.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception><exception cref='T:CBORException'>The string is not in
            JSON format.</exception>

</doc>
<doc name="M:CBORObject.FromJSONString(System.String,CBOREncodeOptions)">

            <summary>Generates a CBOR object from a text string in JavaScript
            Object Notation (JSON) format, using the specified options to
            control the decoding process.
            <para>By default, if a JSON object has the same key, only the last
            given value will be used for each duplicated key.</para></summary><param name='str'>A string in JSON format. The entire string must
            contain a single JSON object and not multiple objects. The string
            may not begin with a byte-order mark (U+FEFF).</param><param name='options'>The parameter <paramref name='options'/> is a
            CBOREncodeOptions object.</param><returns>A CBORObject object.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception><exception cref='T:CBORException'>The string is not in
            JSON format.</exception>

</doc>
<doc name="M:CBORObject.FromObject(PeterO.BigInteger)">

            <summary>Generates a CBOR object from an arbitrary-precision integer.
    </summary><param name='bigintValue'>An arbitrary-precision value.
    </param><returns>A CBOR number.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(CBORObject)">

            <summary>Generates a CBOR object from a CBOR object.
    </summary><param name='value'>The parameter
      <paramref name='value'/>
       is a CBOR object.
    </param><returns>Same as.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(CBORObject[])">

            <summary>Generates a CBOR object from an array of CBOR objects.
    </summary><param name='array'>An array of CBOR objects.
    </param><returns>A CBOR object where each element of the given array is copied to a new
      array, or CBORObject.Null if the value is null.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(PeterO.ExtendedDecimal)">

            <summary>Generates a CBOR object from a decimal number.
    </summary><param name='otherValue'>An arbitrary-precision decimal number.
    </param><returns>A CBOR number.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(PeterO.ExtendedFloat)">

            <summary>Generates a CBOR object from an arbitrary-precision binary floating-point
      number.
    </summary><param name='bigValue'>An arbitrary-precision binary floating-point number.
    </param><returns>A CBOR number.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(PeterO.ExtendedRational)">

            <summary>Generates a CBOR object from an arbitrary-precision binary floating-point
      number.
    </summary><param name='bigValue'>An arbitrary-precision binary floating-point number.
    </param><returns>A CBOR number.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(PeterO.Numbers.EDecimal)">

            <summary>Generates a CBOR object from a decimal number.
    </summary><param name='otherValue'>An arbitrary-precision decimal number.
    </param><returns>A CBOR number.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(PeterO.Numbers.EFloat)">

            <summary>Generates a CBOR object from an arbitrary-precision binary floating-point
      number.
    </summary><param name='bigValue'>An arbitrary-precision binary floating-point number.
    </param><returns>A CBOR number.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(PeterO.Numbers.EInteger)">

            <summary>Generates a CBOR object from an arbitrary-precision integer.
    </summary><param name='bigintValue'>An arbitrary-precision value.
    </param><returns>A CBOR number.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(PeterO.Numbers.ERational)">

            <summary>Generates a CBOR object from a rational number.
    </summary><param name='bigValue'>A rational number.
    </param><returns>A CBOR number.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(System.Boolean)">

            <summary>Returns the CBOR true value or false value, depending on "value".
    </summary><param name='value'>Either True or False.
    </param><returns>CBORObject.True if value is true; otherwise CBORObject.False.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(System.Byte)">

            <summary>Generates a CBOR object from a byte (0 to 255).
    </summary><param name='value'>The parameter
      <paramref name='value'/>
       is a byte (from 0 to 255).
    </param><returns>A CBORObject object.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(System.Byte[])">

            <summary><para>Generates a CBOR object from a byte array. The byte
            array is copied to a new byte array. (This method can't be used to
            decode CBOR data from a byte array; for that, use the
            DecodeFromBytes method instead.).</para>
             </summary><param name='bytes'>A byte array. Can be null.</param><returns>A CBOR byte string object where each byte of the given
            byte array is copied to a new array, or CBORObject.Null if the
            value is null.</returns><example><para>The following example encodes a text string to a UTF-8 byte
            array, then uses the array to create a CBOR byte string object. It
            is not recommended to use <c>Encoding.UTF8.GetBytes</c>
             in .NET, or
            the <c>getBytes()</c>
             method in Java to do this. For instance,
            <c>Encoding.UTF8</c>
             begins the encoded string with a byte-order
            mark, and <c>getBytes()</c>
             encodes text strings in an unspecified
            character encoding. Both behaviors can be undesirable. Instead, use
            the <c>DataUtilities.GetUtf8Bytes</c>
             method to convert text
            strings to UTF-8.</para>
            <code>/* true does character replacement of
            invalid UTF-8; false throws an exception
            on invalid UTF-8 */
            byte[] bytes = DataUtilities.GetUtf8Bytes(
            textString, true);
            CBORObject cbor = CBORObject.FromBytes(bytes);
            </code>
            </example>

</doc>
<doc name="M:CBORObject.FromObject(System.Char)">

            <summary>Generates a CBOR string object from a Unicode
            character.</summary><param name='value'>The parameter <paramref name='value'/> is a
            char object.</param><returns>A CBORObject object.</returns><exception cref='T:System.ArgumentException'>The parameter
            <paramref name='value'/> is a surrogate code point.</exception><remarks>Note that this method's behavior may change in the future.
            Currently, it converts ' char's to text strings, but it may change
            to convert them to integers instead.</remarks>

</doc>
<doc name="M:CBORObject.FromObject(System.Decimal)">

            <summary>Converts a .NET decimal to a CBOR object.
    </summary><param name='value'>The parameter
      <paramref name='value'/>
       is a Decimal object.
    </param><returns>A CBORObject object with the same value as the .NET decimal.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(System.Double)">

            <summary>Generates a CBOR object from a 64-bit floating-point number.
    </summary><param name='value'>The parameter
      <paramref name='value'/>
       is a 64-bit floating-point number.
    </param><returns>A CBORObject object.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(System.Int16)">

            <summary>Generates a CBOR object from a 16-bit signed integer.
    </summary><param name='value'>The parameter
      <paramref name='value'/>
       is a 16-bit signed integer.
    </param><returns>A CBORObject object.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(System.Int32)">

            <summary>Generates a CBOR object from a 32-bit signed integer.
    </summary><param name='value'>The parameter
      <paramref name='value'/>
       is a 32-bit signed integer.
    </param><returns>A CBORObject object.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(System.Int32[])">

            <summary>Generates a CBOR object from an array of 32-bit integers.
    </summary><param name='array'>An array of 32-bit integers.
    </param><returns>A CBOR array object where each element of the given array is copied to a
      new array, or CBORObject.Null if the value is null.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(System.Int64)">

            <summary>Generates a CBOR object from a 64-bit signed integer.
    </summary><param name='value'>The parameter
      <paramref name='value'/>
       is a 64-bit signed integer.
    </param><returns>A CBORObject object.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(System.Int64[])">

            <summary>Generates a CBOR object from an array of 64-bit integers.
    </summary><param name='array'>An array of 64-bit integers.
    </param><returns>A CBOR array object where each element of the given array is copied to a
      new array, or CBORObject.Null if the value is null.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(System.Object)">

            <summary>Generates a CBORObject from an arbitrary object. See the overload of this
      method that takes a PODOptions argument.
    </summary><param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param><returns>A CBOR object corresponding to the given object. Returns CBORObject.Null
      if the object is null.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(System.Object,PODOptions)">

            <summary><para>Generates a CBORObject from an arbitrary object, using the
             given options to control how certain objects are converted to CBOR
             objects. The following types are specially handled by this method:
             null; primitive types; string; CBORObject; the <c>EDecimal</c>,
             <c>EFloat</c>, <c>EInteger</c>, and <c>ERational</c> classes in
             the new
             <a href='https://www.nuget.org/packages/PeterO.Numbers'><c>PeterO.Numbers</c></a>
             library (in .NET) or the
             <a href='https://github.com/peteroupc/numbers-java'><c>com.github.peteroupc/numbers</c></a>
             artifact (in Java); the legacy <c>ExtendedDecimal</c>,
             <c>ExtendedFloat</c>, <c>BigInteger</c>, and
             <c>ExtendedRational</c> classes in this library; arrays;
             enumerations ( <c>Enum</c> objects); and maps. (See also the other
             overloads to the FromObject method.)</para>
             <para>In the .NET version, if the object is a type not specially
             handled by this method, returns a CBOR map with the values of each
             of its read/write properties (or all properties in the case of a
             compiler-generated type). Properties are converted to their
             camel-case names (meaning if a name starts with A to Z, that letter
             is lower-cased). If the property name begins with the word "Is"
             followed by an upper-case A to Z, the "Is" prefix is deleted from
             the name. (Passing the appropriate "options" parameter can be done
             to control whether the "Is" prefix is removed and whether a
             camel-case conversion happens.) Also, .NET <c>Enum</c> objects will
             be converted to their integer values, and a multidimensional array
             is converted to an array of arrays.</para>
             <para>In the Java version, if the object is a type not specially
             handled by this method, this method checks the CBOR object for
             methods starting with the word "get" or "is" (either word followed
             by an upper-case A to Z) that take no parameters, and returns a
             CBOR map with one entry for each such method found. For each method
             found, the starting word "get" or "is" is deleted from its name,
             and the name is converted to camel case (meaning if a name starts
             with A to Z, that letter is lower-cased). (Passing the appropriate
             "options" parameter can be done to control whether the "is" prefix
             is removed and whether a camel-case conversion happens.) Also, Java
             <c>Enum</c> objects will be converted to the result of their
             <c>name</c> method.</para>
             <para>If the input is a byte array, the byte array is copied to a
             new byte array. (This method can't be used to decode CBOR data from
             a byte array; for that, use the DecodeFromBytes method
             instead.).</para>

<para>If the input is a text string, a CBOR text string object will be created.  To create a CBOR byte string object from a text string, see the example given in
<see cref='M:CBORObject.FromObject(System.Byte[])'/>.</para>
<para>REMARK: The behavior of this method is likely to change in the next major version (4.0).  There are certain inconsistencies between the ToObject method and the FromObject method as well as between the .NET and Java versions of FromObject.  For one thing, DateTime/Date objects are converted differently between the two versions -- either as CBOR maps with their "get" properties (Java) or as tag-0 strings (.NET) -- this difference has to remain for backward compatibility with version 3.0.  For another thing, the treatment of properties/getters starting with "Is" is subtly inconsistent between the .NET and Java versions of FromObject, especially when using certain PODOptions.  A certain consistency between .NET and Java and between FromObject and ToObject are sought for version 4.0.  It is also hoped that--</para><list>
<item>the ToObject method will support deserializing to objects consisting of fields and not getters ("getX()" methods), both in .NET and in Java, and</item>
<item>both FromObject and ToObject will be better designed, in version 4.0, so that backward-compatible improvements are easier to make.</item></list>
</summary><param name='obj'>The parameter <paramref name='obj'/> is an
             arbitrary object.</param><param name='options'>An object containing options to control how
             certain objects are converted to CBOR objects.</param><returns>A CBOR object corresponding to the given object. Returns
             CBORObject.Null if the object is null.</returns><exception cref='T:System.ArgumentNullException'>The parameter <paramref name='options'/> is null.</exception>

</doc>
<doc name="M:CBORObject.FromObject(System.SByte)">

            <summary>Converts a signed 8-bit integer to a CBOR object.
    </summary><param name='value'>The parameter
      <paramref name='value'/>
       is an 8-bit signed integer.
    </param><returns>A CBORObject object.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(System.Single)">

            <summary>Generates a CBOR object from a 32-bit floating-point number.
    </summary><param name='value'>The parameter
      <paramref name='value'/>
       is a 32-bit floating-point number.
    </param><returns>A CBORObject object.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(System.String)">

            <summary>Generates a CBOR object from a text string.</summary><param name='strValue'>A string value. Can be null.</param><returns>A CBOR object representing the string, or CBORObject.Null
            if stringValue is null.</returns><exception cref='T:System.ArgumentException'>The string contains an
            unpaired surrogate code point.</exception>

</doc>
<doc name="M:CBORObject.FromObject(System.UInt16)">

            <summary>Converts a 16-bit unsigned integer to a CBOR object.
    </summary><param name='value'>A 16-bit unsigned integer.
    </param><returns>A CBORObject object.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(System.UInt32)">

            <summary>Converts a 32-bit unsigned integer to a CBOR object.
    </summary><param name='value'>A 32-bit unsigned integer.
    </param><returns>A CBORObject object.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject(System.UInt64)">

            <summary>Converts a 64-bit unsigned integer to a CBOR object.
    </summary><param name='value'>A 64-bit unsigned integer.
    </param><returns>A CBORObject object.
    </returns>

</doc>
<doc name="M:CBORObject.FromObjectAndTag(System.Object,PeterO.BigInteger)">

            <summary>Generates a CBOR object from an arbitrary object and gives
            the resulting object a tag.</summary><param name='valueOb'>An arbitrary object. If the tag number is 2
            or 3, this must be a byte string whose bytes represent an integer
            in little-endian byte order, and the value of the number is 1 minus
            the integer's value for tag 3. If the tag number is 4 or 5, this
            must be an array with two elements: the first must be an integer
            representing the exponent, and the second must be an integer
            representing a mantissa.</param><param name='bigintTag'>Tag number. The tag number 55799 can be
            used to mark a "self-described CBOR" object.  This document does not attempt to list all CBOR tags and their meanings.  An up-to-date list can be found at the CBOR Tags registry maintained by the Internet Assigned Numbers Authority (<i>iana.org/assignments/cbor-tags</i>).</param><returns>A CBOR object where the object <paramref name='valueOb'/>
            is converted to a CBOR object and given the tag <paramref name='bigintTag'/>.</returns><exception cref='T:System.ArgumentException'>The parameter
            <paramref name='bigintTag'/> is less than 0 or greater than 2^64-1,
            or <paramref name='valueOb'/> 's type is unsupported.</exception><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigintTag'/> is null.</exception>

</doc>
<doc name="M:CBORObject.FromObjectAndTag(System.Object,PeterO.Numbers.EInteger)">

            <summary>Generates a CBOR object from an arbitrary object and gives
            the resulting object a tag.</summary><param name='valueOb'>An arbitrary object. If the tag number is 2
            or 3, this must be a byte string whose bytes represent an integer
            in little-endian byte order, and the value of the number is 1 minus
            the integer's value for tag 3. If the tag number is 4 or 5, this
            must be an array with two elements: the first must be an integer
            representing the exponent, and the second must be an integer
            representing a mantissa.</param><param name='bigintTag'>Tag number. The tag number 55799 can be
            used to mark a "self-described CBOR" object.  This document does not attempt to list all CBOR tags and their meanings.  An up-to-date list can be found at the CBOR Tags registry maintained by the Internet Assigned Numbers Authority (<i>iana.org/assignments/cbor-tags</i>).</param><returns>A CBOR object where the object <paramref name='valueOb'/>
            is converted to a CBOR object and given the tag <paramref name='bigintTag'/>.</returns><exception cref='T:System.ArgumentException'>The parameter
            <paramref name='bigintTag'/> is less than 0 or greater than 2^64-1,
            or <paramref name='valueOb'/> 's type is unsupported.</exception><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='bigintTag'/> is null.</exception>

</doc>
<doc name="M:CBORObject.FromObjectAndTag(System.Object,System.Int32)">

            <summary>Generates a CBOR object from an arbitrary object and gives
            the resulting object a tag.</summary><param name='valueObValue'>An arbitrary object. If the tag number
            is 2 or 3, this must be a byte string whose bytes represent an
            integer in little-endian byte order, and the value of the number is
            1 minus the integer's value for tag 3. If the tag number is 4 or 5,
            this must be an array with two elements: the first must be an
            integer representing the exponent, and the second must be an
            integer representing a mantissa.</param><param name='smallTag'>A 32-bit integer that specifies a tag
            number. The tag number 55799 can be used to mark a "self-described
            CBOR" object.  This document does not attempt to list all CBOR tags and their meanings.  An up-to-date list can be found at the CBOR Tags registry maintained by the Internet Assigned Numbers Authority (<i>iana.org/assignments/cbor-tags</i>).</param><returns>A CBOR object where the object <paramref name='valueObValue'/> is converted to a CBOR object and given the
            tag <paramref name='smallTag'/>.</returns><exception cref='T:System.ArgumentException'>The parameter
            <paramref name='smallTag'/> is less than 0 or <paramref name='valueObValue'/> 's type is unsupported.</exception>

</doc>
<doc name="M:CBORObject.FromObjectAndTag(System.Object,System.UInt64)">

            <summary>Generates a CBOR object from an arbitrary object and gives the resulting
      object a tag.
    </summary><param name='o'>The parameter
      <paramref name='o'/>
       is an arbitrary object.
    </param><param name='tag'>A 64-bit integer that specifies a tag
            number. The tag number 55799 can be used to mark a "self-described
            CBOR" object.  This document does not attempt to list all CBOR tags and their meanings.  An up-to-date list can be found at the CBOR Tags registry maintained by the Internet Assigned Numbers Authority (<i>iana.org/assignments/cbor-tags</i>).
    </param><returns>A CBOR object where the object
      <paramref name='o'/>
       is converted to a CBOR object and given the tag
      <paramref name='tag'/>
       .
    </returns>

</doc>
<doc name="M:CBORObject.FromObject``1(System.Collections.Generic.IEnumerable{``0})">

            <summary>Generates a CBOR object from an enumerable set of objects.
    </summary><param name='value'>An object that implements the IEnumerable interface. In the .NET version,
      this can be the return value of an iterator or the result of a LINQ query.

    </param><typeparam name='T'>
       A type convertible to CBORObject.
    </typeparam><returns>A CBOR object where each element of the given enumerable object is
      converted to a CBOR object and copied to a new array, or CBORObject.Null
      if the value is null.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject``1(System.Collections.Generic.IList{``0})">

            <summary>Generates a CBOR object from a list of objects.
    </summary><param name='value'>An array of CBOR objects. Can be null.
    </param><typeparam name='T'>
       A type convertible to CBORObject.
    </typeparam><returns>A CBOR object where each element of the given array is converted to a
      CBOR object and copied to a new array, or CBORObject.Null if the value is
      null.
    </returns>

</doc>
<doc name="M:CBORObject.FromObject``2(System.Collections.Generic.IDictionary{``0,``1})">

            <summary>Generates a CBOR object from a map of objects.
    </summary><param name='dic'>A map of CBOR objects.
    </param><typeparam name='TKey'>
       A type convertible to CBORObject; the type of the keys.
    </typeparam><typeparam name='TValue'>
       A type convertible to CBORObject; the type of the values.
    </typeparam><returns>A CBOR object where each key and value of the given map is converted to a
      CBOR object and copied to a new map, or CBORObject.Null if
      <paramref name='dic'/>
       is null.
    </returns>

</doc>
<doc name="M:CBORObject.FromSimpleValue(System.Int32)">

            <summary>Creates a CBOR object from a simple value
            number.</summary><param name='simpleValue'>The parameter <paramref name='simpleValue'/> is a 32-bit signed integer.</param><returns>A CBORObject object.</returns><exception cref='T:System.ArgumentException'>The parameter
            <paramref name='simpleValue'/> is less than 0, greater than 255, or
            from 24 through 31.</exception>

</doc>
<doc name="M:CBORObject.GetAllTags">

            <summary>Gets a list of all tags, from outermost to innermost.
    </summary><returns>An array of tags, or the empty string if this object is untagged.
    </returns>

</doc>
<doc name="M:CBORObject.GetByteString">

            <summary>Gets the byte array used in this object, if this object is
            a byte string, without copying the data to a new one. This method's
            return value can be used to modify the array's contents. Note,
            though, that the array' s length can't be changed.</summary><returns>The byte array held by this CBOR object.</returns><exception cref='T:System.InvalidOperationException'>This object is
            not a byte string.</exception>

</doc>
<doc name="M:CBORObject.GetHashCode">

            <summary>Calculates the hash code of this object. No application or process IDs
      are used in the hash code calculation.
    </summary><returns>A 32-bit hash code.
    </returns>

</doc>
<doc name="M:CBORObject.GetTags">

            <summary>Gets a list of all tags, from outermost to innermost.
    </summary><returns>An array of tags, or the empty string if this object is untagged.
    </returns>

</doc>
<doc name="M:CBORObject.HasTag(PeterO.BigInteger)">

            <summary>Returns whether this object has a tag of the given
            number.</summary><param name='bigTagValue'>The tag value to search for.</param><returns><c>true</c> if this object has a tag of the given number; otherwise, <c>false</c>.</returns><exception cref='T:System.ArgumentNullException'>BigTagValue is
            null.</exception><exception cref='T:System.ArgumentException'>BigTagValue is less
            than 0.</exception>

</doc>
<doc name="M:CBORObject.HasTag(PeterO.Numbers.EInteger)">

            <summary>Returns whether this object has a tag of the given
            number.</summary><param name='bigTagValue'>The tag value to search for.</param><returns><c>true</c> if this object has a tag of the given number; otherwise, <c>false</c>.</returns><exception cref='T:System.ArgumentNullException'>BigTagValue is
            null.</exception><exception cref='T:System.ArgumentException'>BigTagValue is less
            than 0.</exception>

</doc>
<doc name="M:CBORObject.HasTag(System.Int32)">

            <summary>Returns whether this object has a tag of the given
            number.</summary><param name='tagValue'>The tag value to search for.</param><returns><c>true</c> if this object has a tag of the given number; otherwise, <c>false</c>.</returns><exception cref='T:System.ArgumentException'>TagValue is less than
            0.</exception><exception cref='T:System.ArgumentNullException'>The parameter
            "obj" is null.</exception>

</doc>
<doc name="P:CBORObject.InnermostTag">

            <summary>Gets the last defined tag for this CBOR data item, or -1 if the item is
      untagged.
    </summary><value>The last defined tag for this CBOR data item, or -1 if the item is
      untagged.
    </value>

</doc>
<doc name="M:CBORObject.Insert(System.Int32,System.Object)">

            <summary>Inserts an object at the specified position in this CBOR
            array.</summary><param name='index'>Zero-based index to insert at.</param><param name='valueOb'>An object representing the value, which will
            be converted to a CBORObject. Can be null, in which case this value
            is converted to CBORObject.Null.</param><returns>This instance.</returns><exception cref='T:System.InvalidOperationException'>This object is
            not an array.</exception><exception cref='T:System.ArgumentException'>The parameter
            <paramref name='valueOb'/> has an unsupported type; or <paramref name='index'/> is not a valid index into this array.</exception>

</doc>
<doc name="P:CBORObject.IsFalse">

            <summary>Gets a value indicating whether this value is a CBOR false value.
    </summary><value><c>true</c>
       If this value is a CBOR false value; otherwise, .
      <c>false</c>
       .
    </value>

</doc>
<doc name="P:CBORObject.IsFinite">

            <summary>Gets a value indicating whether this CBOR object
             represents a finite number.</summary><value><c>true</c> If this CBOR object represents a finite number;
             otherwise, . <c>false</c>.</value>

</doc>
<doc name="M:CBORObject.IsInfinity">

            <summary>Gets a value indicating whether this CBOR object represents infinity.
    </summary><returns><c>true</c>
       if this CBOR object represents infinity; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="P:CBORObject.IsIntegral">

            <summary>Gets a value indicating whether this object represents an
             integral number, that is, a number without a fractional part.
             Infinity and not-a-number are not considered integral.</summary><value><c>true</c> If this object represents an integral number,
             that is, a number without a fractional part; otherwise, .
             <c>false</c>.</value>

</doc>
<doc name="M:CBORObject.IsNaN">

            <summary>Gets a value indicating whether this CBOR object represents a
      not-a-number value (as opposed to whether this object's type is not a
      number type).
    </summary><returns><c>true</c>
       if this CBOR object represents a not-a-number value (as opposed to
      whether this object's type is not a number type); otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="P:CBORObject.IsNegative">

            <summary>Gets a value indicating whether this object is a negative number.
    </summary><value><c>true</c>
       If this object is a negative number; otherwise, .
      <c>false</c>
       .
    </value>

</doc>
<doc name="M:CBORObject.IsNegativeInfinity">

            <summary>Gets a value indicating whether this CBOR object represents negative
      infinity.
    </summary><returns><c>true</c>
       if this CBOR object represents negative infinity; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="P:CBORObject.IsNull">

            <summary>Gets a value indicating whether this value is a CBOR null
             value.</summary><value><c>true</c> If this value is a CBOR null value; otherwise, .
             <c>false</c>.</value>

</doc>
<doc name="M:CBORObject.IsPositiveInfinity">

            <summary>Gets a value indicating whether this CBOR object represents positive
      infinity.
    </summary><returns><c>true</c>
       if this CBOR object represents positive infinity; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="P:CBORObject.IsTagged">

            <summary>Gets a value indicating whether this data item has at
             least one tag.</summary><value><c>true</c> If this data item has at least one tag;
             otherwise, . <c>false</c>.</value>

</doc>
<doc name="P:CBORObject.IsTrue">

            <summary>Gets a value indicating whether this value is a CBOR true
             value.</summary><value><c>true</c> If this value is a CBOR true value; otherwise, .
             <c>false</c>.</value>

</doc>
<doc name="P:CBORObject.IsUndefined">

            <summary>Gets a value indicating whether this value is a CBOR
             undefined value.</summary><value><c>true</c> If this value is a CBOR undefined value;
             otherwise, . <c>false</c>.</value>

</doc>
<doc name="P:CBORObject.IsZero">
<summary>Gets a value indicating whether this object's value equals 0.
    </summary>
    <value><c>true</c>
       If this object&apos;s value equals 0; otherwise, .
      <c>false</c>
       .
    </value>
</doc>
<doc name="P:CBORObject.Item(CBORObject)">

            <summary>Gets the value of a CBOR object in this map, using a CBOR
            object as the key.</summary><param name='key'>The parameter <paramref name='key'/> is a CBOR
            object.</param><returns>A CBORObject object.</returns><exception cref='T:System.ArgumentNullException'>The key is null
            (as opposed to CBORObject.Null); or the set method is called and
            the value is null.</exception><exception cref='T:System.InvalidOperationException'>This object is
            not a map.</exception>

</doc>
<doc name="P:CBORObject.Item(System.Int32)">

            <summary>Gets the value of a CBOR object by integer index in this
            array.</summary><param name='index'>Zero-based index of the element.</param><returns>A CBORObject object.</returns><exception cref='T:System.InvalidOperationException'>This object is
            not an array.</exception><exception cref='T:System.ArgumentNullException'>The parameter
            "value" is null (as opposed to CBORObject.Null).</exception>

</doc>
<doc name="P:CBORObject.Item(System.String)">

            <summary>Gets the value of a CBOR object in this map, using a
            string as the key.</summary><param name='key'>A key that points to the desired value.</param><returns>A CBORObject object.</returns><exception cref='T:System.ArgumentNullException'>The key is
            null.</exception><exception cref='T:System.InvalidOperationException'>This object is
            not a map.</exception>

</doc>
<doc name="P:CBORObject.Keys">

            <summary>Gets a collection of the keys of this CBOR object in an
            undefined order.</summary><value>A collection of the keys of this CBOR object.</value><exception cref='T:System.InvalidOperationException'>This object is
            not a map.</exception>

</doc>
<doc name="P:CBORObject.MostInnerTag">

            <summary>Gets the last defined tag for this CBOR data item, or -1 if the item is
      untagged.
    </summary><value>The last defined tag for this CBOR data item, or -1 if the item is
      untagged.
    </value>

</doc>
<doc name="P:CBORObject.MostOuterTag">

            <summary>Gets the outermost tag for this CBOR data item, or -1 if the item is
      untagged.
    </summary><value>The outermost tag for this CBOR data item, or -1 if the item is untagged.

    </value>

</doc>
<doc name="M:CBORObject.Multiply(CBORObject,CBORObject)">

            <summary>Multiplies two CBOR numbers.</summary><param name='first'>The parameter <paramref name='first'/> is a
            CBOR object.</param><param name='second'>The parameter <paramref name='second'/> is a
            CBOR object.</param><returns>The product of the two numbers.</returns><exception cref='T:System.ArgumentException'>Either or both
            operands are not numbers (as opposed to Not-a-Number,
            NaN).</exception>

</doc>
<doc name="F:CBORObject.NaN">

            <summary>A not-a-number value.
    </summary>

</doc>
<doc name="M:CBORObject.Negate">

            <summary>Gets this object's value with the sign reversed.</summary><returns>The reversed-sign form of this number.</returns><exception cref='T:System.InvalidOperationException'>This object's
            type is not a number type.</exception>

</doc>
<doc name="F:CBORObject.NegativeInfinity">

            <summary>The value negative infinity.
    </summary>

</doc>
<doc name="M:CBORObject.NewArray">

            <summary>Creates a new empty CBOR array.
    </summary><returns>A new CBOR array.
    </returns>

</doc>
<doc name="M:CBORObject.NewMap">

            <summary>Creates a new empty CBOR map.
    </summary><returns>A new CBOR map.
    </returns>

</doc>
<doc name="F:CBORObject.Null">

            <summary>Represents the value null.
    </summary>

</doc>
<doc name="P:CBORObject.OutermostTag">

            <summary>Gets the outermost tag for this CBOR data item, or -1 if the item is
      untagged.
    </summary><value>The outermost tag for this CBOR data item, or -1 if the item is untagged.

    </value>

</doc>
<doc name="F:CBORObject.PositiveInfinity">

            <summary>The value positive infinity.
    </summary>

</doc>
<doc name="M:CBORObject.Read(System.IO.Stream)">

            <summary><para><b>At the moment, use the overload of this method that takes
            a
            <see cref='T:CBOREncodeOptions'/> object. The object
            <c>CBOREncodeOptions.Default</c> contains recommended settings for
            CBOREncodeOptions, and those settings may be adopted by this
            overload (without a CBOREncodeOptions argument) in the next major
            version.</b></para>
            <para>Reads an object in CBOR format from a data stream. This
            method will read from the stream until the end of the CBOR object
            is reached or an error occurs, whichever happens
            first.</para></summary><param name='stream'>A readable data stream.</param><returns>A CBOR object that was read.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:CBORException'>There was an error in
            reading or parsing the data.</exception>

</doc>
<doc name="M:CBORObject.Read(System.IO.Stream,CBOREncodeOptions)">

            <summary>Reads an object in CBOR format from a data stream, using
            the specified options to control the decoding process. This method
            will read from the stream until the end of the CBOR object is
            reached or an error occurs, whichever happens first.</summary><param name='stream'>A readable data stream.</param><param name='options'>The parameter <paramref name='options'/> is a
            CBOREncodeOptions object.</param><returns>A CBOR object that was read.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:CBORException'>There was an error in
            reading or parsing the data.</exception>

</doc>
<doc name="M:CBORObject.ReadJSON(System.IO.Stream)">

            <summary>Generates a CBOR object from a data stream in JavaScript
            Object Notation (JSON) format. The JSON stream may begin with a
            byte-order mark (U+FEFF). Since version 2.0, the JSON stream can
            be in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected
            by assuming that the first character read must be a byte-order mark
            or a nonzero basic character (U+0001 to U+007F). (In previous
            versions, only UTF-8 was allowed.)
            <para>If a JSON object has the same key, only the last given value
            will be used for each duplicated key.</para></summary><param name='stream'>A readable data stream. The sequence of bytes
            read from the data stream must contain a single JSON object and not
            multiple objects.</param><returns>A CBORObject object.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception><exception cref='T:CBORException'>The data stream
            contains invalid encoding or is not in JSON format.</exception>

</doc>
<doc name="M:CBORObject.ReadJSON(System.IO.Stream,CBOREncodeOptions)">

            <summary>Generates a CBOR object from a data stream in JavaScript
            Object Notation (JSON) format, using the specified options to
            control the decoding process. The JSON stream may begin with a
            byte-order mark (U+FEFF). Since version 2.0, the JSON stream can
            be in UTF-8, UTF-16, or UTF-32 encoding; the encoding is detected
            by assuming that the first character read must be a byte-order mark
            or a nonzero basic character (U+0001 to U+007F). (In previous
            versions, only UTF-8 was allowed.)
            <para>By default, if a JSON object has the same key, only the last
            given value will be used for each duplicated key.</para></summary><param name='stream'>A readable data stream. The sequence of bytes
            read from the data stream must contain a single JSON object and not
            multiple objects.</param><param name='options'>The parameter <paramref name='options'/> is a
            CBOREncodeOptions object.</param><returns>A CBORObject object.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception><exception cref='T:CBORException'>The data stream
            contains invalid encoding or is not in JSON format.</exception>

</doc>
<doc name="M:CBORObject.Remainder(CBORObject,CBORObject)">

            <summary>Finds the remainder that results when a CBORObject object is divided by
      the value of a CBORObject object.
    </summary><param name='first'>The parameter
      <paramref name='first'/>
       is a CBOR object.
    </param><param name='second'>The parameter
      <paramref name='second'/>
       is a CBOR object.
    </param><returns>The remainder of the two numbers.
    </returns>

</doc>
<doc name="M:CBORObject.Remove(CBORObject)">

            <summary>If this object is an array, removes the first instance of
            the specified item from the array. If this object is a map, removes
            the item with the given key from the map.</summary><param name='obj'>The item or key to remove.</param><returns><c>true</c> if the item was removed; otherwise, <c>false</c>.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='obj'/> is null (as opposed to
            CBORObject.Null).</exception><exception cref='T:System.InvalidOperationException'>The object is
            not an array or map.</exception>

</doc>
<doc name="M:CBORObject.Remove(System.Object)">

            <summary>If this object is an array, removes the first instance of
            the specified item (once converted to a CBOR object) from the array. If this object is a map, removes
            the item with the given key (once converted to a CBOR object) from the map.</summary><param name='obj'>The item or key (once converted to a CBOR object) to remove.</param><returns><c>true</c> if the item was removed; otherwise, <c>false</c>.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='obj'/> is null (as opposed to
            CBORObject.Null).</exception><exception cref='T:System.InvalidOperationException'>The object is
            not an array or map.</exception>

</doc>
<doc name="M:CBORObject.RemoveAt(System.Int32)">
<summary>Removes the item at the given index of this CBOR array.
    </summary>
    <param name='index'>The index, starting at 0, of the item to remove.
    </param>
    <returns>Returns "true" if the object was removed. Returns "false" if the given
      index is less than 0, or is at least as high as the number of items in the
      array.
    </returns>
    <exception cref='InvalidOperationException'>This object is not a CBOR array.
    </exception>
</doc>
<doc name="M:CBORObject.Set(System.Object,System.Object)">

            <summary>Maps an object to a key in this CBOR map, or adds the
            value if the key doesn't exist.</summary><param name='key'>An object representing the key, which will be
            converted to a CBORObject. Can be null, in which case this value is
            converted to CBORObject.Null.</param><param name='valueOb'>An object representing the value, which will
            be converted to a CBORObject. Can be null, in which case this value
            is converted to CBORObject.Null.</param><returns>This instance.</returns><exception cref='T:System.InvalidOperationException'>This object is
            not a map.</exception><exception cref='T:System.ArgumentException'>The parameter
            <paramref name='key'/> or <paramref name='valueOb'/> has an
            unsupported type.</exception>

</doc>
<doc name="P:CBORObject.Sign">
<summary>Gets this value's sign: -1 if negative; 1 if positive; 0 if zero.
    </summary>
    <value>This value&#x27;s sign: -1 if negative; 1 if positive; 0 if zero.
    </value>
    <exception cref='T:System.InvalidOperationException'>This object's type is not a number type, including the special
      not-a-number value (NaN).
    </exception>
</doc>
<doc name="P:CBORObject.SimpleValue">

            <summary>Gets the simple value ID of this object, or -1 if this object is not a
      simple value (including if the value is a floating-point number).
    </summary><value>The simple value ID of this object, or -1 if this object is not a simple
      value (including if the value is a floating-point number).
    </value>

</doc>
<doc name="M:CBORObject.Subtract(CBORObject,CBORObject)">

            <summary>Finds the difference between two CBOR number
            objects.</summary><param name='first'>The parameter <paramref name='first'/> is a
            CBOR object.</param><param name='second'>The parameter <paramref name='second'/> is a
            CBOR object.</param><returns>The difference of the two objects.</returns><exception cref='T:System.ArgumentException'>Either or both
            operands are not numbers (as opposed to Not-a-Number,
            NaN).</exception>

</doc>
<doc name="M:CBORObject.ToJSONString">

            <summary>Converts this object to a string in JavaScript Object
             Notation (JSON) format, using the specified options to control the
             encoding process. See the overload to JSONString taking a
             JSONOptions argument.
             <para>If the CBOR object contains CBOR maps, or is a CBOR map
             itself, the keys to the map are written out to the JSON string in
             an undefined order. The example code given in
             <see cref='M:CBORObject.ToJSONString(JSONOptions)'/>
             can be used to write out certain keys of a CBOR map in a given
             order to a JSON string.</para></summary><returns>A text string.</returns>

</doc>
<doc name="M:CBORObject.ToJSONString(JSONOptions)">
<summary>Converts this object to a string in JavaScript Object Notation (JSON)
      format, using the specified options to control the encoding process. This
      function works not only with arrays and maps, but also integers, strings,
      byte arrays, and other JSON data types. Notes:
      <list type=''>
        <item>If this object contains maps with non-string keys, the keys are
          converted to JSON strings before writing the map as a JSON string.
        </item>
        <item>If the CBOR object contains CBOR maps, or is a CBOR map itself, the
          keys to the map are written out to the JSON string in an undefined
          order.
        </item>
        <item>If a number in the form of an arbitrary-precision binary float has a
          very high binary exponent, it will be converted to a double before
          being converted to a JSON string. (The resulting double could overflow
          to infinity, in which case the arbitrary-precision binary float is
          converted to null.)
        </item>
        <item>The string will not begin with a byte-order mark (U+FEFF); RFC 8259
          (the JSON specification) forbids placing a byte-order mark at the
          beginning of a JSON string.
        </item>
        <item>Byte strings are converted to Base64 URL without whitespace or padding
          by default (see section 4.1 of RFC 7049). A byte string will instead
          be converted to traditional base64 without whitespace or padding by
          default if it has tag 22, or base16 for tag 23. Padding will be
          included in the Base64 URL or traditional base64 form if
          <b>Base64Padding</b>
           in the JSON options is set to
          <b>true</b>
           . (To create a CBOR object with a given tag, call the
          <c>CBORObject.FromObjectAndTag</c>
           method and pass the CBOR object and the desired tag number to that
          method.)
        </item>
        <item>Rational numbers will be converted to their exact form, if possible,
          otherwise to a high-precision approximation. (The resulting
          approximation could overflow to infinity, in which case the rational
          number is converted to null.)
        </item>
        <item>Simple values other than true and false will be converted to null.
          (This doesn't include floating-point numbers.)
        </item>
        <item>Infinity and not-a-number will be converted to null.
        </item>
      </list>
      <para>The example code given below (originally written in C# for the .NET
        version) can be used to write out certain keys of a CBOR map in a given
        order to a JSON string.
      </para>
      <code>/* Generates a JSON string of 'mapObj' whose keys are in the order given
        in 'keys' . Only keys found in 'keys' will be written if they exist in
        'mapObj'. */ private static string KeysToJSONMap&#x28;CBORObject mapObj,
        IList&lt;CBORObject&gt; keys&#x29;&#x7b; if (mapObj == null) { throw new
        ArgumentNullException&#x29;nameof(mapObj));} if (keys == null) { throw
        new ArgumentNullException&#x29;nameof(keys));} if (obj.Type !=
        CBORType.Map) { throw new ArgumentException("'obj' is not a map."); }
        StringBuilder builder = new StringBuilder(); var first = true;
        builder.Append("{"); for (CBORObject key in keys) { if
        (mapObj.ContainsKey(key)) { if (!first) {builder.Append(", ");} var
        keyString=(key.CBORType == CBORType.String) ? key.AsString() :
        key.ToJSONString(); builder.Append(CBORObject.FromObject(keyString)
        .ToJSONString()) .Append(":").Append(mapObj[key].ToJSONString());
        first=false; } } return builder.Append("}").ToString(); }
      </code>
    </summary>
    <param name='options'>An object containing the options to control writing the CBOR object to
      JSON.
    </param>
    <returns>A text string containing the converted object.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='options'/>
       is null.
    </exception>
</doc>
<doc name="M:CBORObject.ToObject(System.Type)">
<summary>Converts this CBOR object to an object of an arbitrary type. See the
      documentation for the overload of this method taking a CBORTypeMapper
      parameter for more information. This method (without a CBORTypeMapper
      parameter) allows all data types not otherwise handled to be eligible for
      Plain-Old-Data serialization.
    </summary>
    <param name='t'>The type, class, or interface that this method's return value will belong
      to. To express a generic type in Java, see the example.
      <b>Note:</b>
       For security reasons, an application should not base this parameter on
      user input or other externally supplied data. Whenever possible, this
      parameter should be either a type specially handled by this method (such
      as
      <c>int</c>
       or
      <c>String</c>
       ) or a plain-old-data type (POCO or POJO type) within the control of the
      application. If the plain-old-data type references other data types, those
      types should likewise meet either criterion above.
    </param>
    <returns>The converted object.
    </returns>
    <exception cref='T:System.NotSupportedException'>The given type
      <paramref name='t'/>
       , or this object's CBOR type, is not supported.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='t'/>
       is null.
    </exception>
    <exception cref='T:System.CBORException'>The given object's nesting is too deep, or another error occurred when
      serializing the object.
    </exception>
    <example><para>Java offers no easy way to express a generic type, at least none as easy
        as C#'s
        <c>typeof</c>
         operator. The following example, written in Java, is a way to specify
        that the return value will be an ArrayList of String objects.
      </para>
      <code>Type arrayListString = new ParameterizedType(){ public Type[]
        getActualTypeArguments(){ /* Contains one type parameter, String */
        return new Type[]{ String.class }; } public Type getRawType(){ /* Raw
        type is ArrayList */ return ArrayList.class; } public Type
        getOwnerType(){ return null; } }; ArrayList&lt;String&gt; array =
        (ArrayList&lt;String&gt;) cborArray.ToObject(arrayListString);
      </code>
      <para>By comparison, the C# version is much shorter.
      </para>
      <code>var&#x20;array = (List&lt;String&gt;)cborArray.ToObject(
        typeof&#x28;List&lt;String&gt;));
      </code>
    </example>
</doc>
<doc name="M:CBORObject.ToObject(System.Type,CBORTypeMapper)">

            <summary>Converts this CBOR object to an object of an arbitrary
            type. See the documentation for the overload of this method taking
            a CBORTypeMapper and PODOptions parameters parameters for more information.</summary><param name='t'>The type, class, or interface that this method's
            return value will belong to. To express a generic type in Java, see
            the example. <b>Note:</b>
             For security reasons, an application
            should not base this parameter on user input or other externally
            supplied data. Whenever possible, this parameter should be either a
            type specially handled by this method (such as <c>int</c>
             or
            <c>String</c>
             ///) or a plain-old-data type (POCO or POJO type)
            within the control of the application. If the plain-old-data type
            references other data types, those types should likewise meet
            either criterion above.</param><param name='mapper'>This parameter controls which data types are
            eligible for Plain-Old-Data deserialization and includes custom
            converters from CBOR objects to certain data types.</param><returns>The converted object.</returns><exception cref='T:System.NotSupportedException'>The given type
            <paramref name='t'/> , or this object's CBOR type, is not
            supported.</exception><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='t'/> is null.</exception><exception cref='T:System.CBORException'>The given object's nesting
            is too deep, or another error occurred when serializing the
            object.</exception>

</doc>
<doc name="M:CBORObject.ToObject(System.Type,CBORTypeMapper,PODOptions)">
<summary><para>Converts this CBOR object to an object of an arbitrary type. The
        following cases are checked in the logical order given (rather than the
        strict order in which they are implemented by this library):
      </para>
      <list>
        <item>If the type is
          <c>CBORObject</c>
           , return this object.
        </item>
        <item>If the given object is
          <c>CBORObject.Null</c>
           (with or without tags), returns
          <c>null</c>
           .
        </item>
        <item>If the object is of a type corresponding to a type converter mentioned
          in the
          <paramref name='mapper'/>
           parameter, that converter will be used to convert the CBOR object to
          an object of the given type. Type converters can be used to override
          the default conversion behavior of almost any object.
        </item>
        <item>If the type is
          <c>object</c>
           , return this object.
        </item>
        <item>If the type is
          <c>char</c>
           , converts single-character CBOR text strings and CBOR integers from
          0 through 65535 to a
          <c>char</c>
           object and returns that
          <c>char</c>
           object.
        </item>
        <item>If the type is
          <c>bool</c>
           (
          <c>boolean</c>
           in Java), returns the result of AsBoolean.
        </item>
        <item>If the type is a primitive integer type (
          <c>byte</c>
           ,
          <c>int</c>
           ,
          <c>short</c>
           ,
          <c>long</c>
           , as well as
          <c>sbyte</c>
           ,
          <c>ushort</c>
           ,
          <c>uint</c>
           , and
          <c>ulong</c>
           in .NET) or a primitive floating-point type (
          <c>float</c>
           ,
          <c>double</c>
           , as well as
          <c>decimal</c>
           in .NET), returns the result of the corresponding As* method.
        </item>
        <item>If the type is
          <c>String</c>
           , returns the result of AsString.
        </item>
        <item>If the type is
          <c>EDecimal</c>
           ,
          <c>EFloat</c>
           ,
          <c>EInteger</c>
           , or
          <c>ERational</c>
           in the
          <a href='https://www.nuget.org/packages/PeterO.Numbers'>
            <c>PeterO.Numbers</c>
          </a>
           library (in .NET) or the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c>
          </a>
           artifact (in Java), returns the result of the corresponding As*
          method.
        </item>
        <item>If the type is an enumeration (
          <c>Enum</c>
           ///) type this CBOR object is a text string or an integer, returns
          the appropriate enumerated constant. (For example, if
          <c>MyEnum</c>
           includes an entry for
          <c>MyValue</c>
           , this method will return
          <c>MyEnum.MyValue</c>
           if the CBOR object represents
          <c>"MyValue"</c>
           or the underlying value for
          <c>MyEnum.MyValue</c>
           .)
          <b>Note:</b>
           If an integer is converted to a .NET Enum constant, and that integer
          is shared by more than one constant of the same type, it is undefined
          which constant from among them is returned. (For example, if
          <c>MyEnum.Zero = 0</c>
           and
          <c>MyEnum.Null = 0</c>
           , converting 0 to
          <c>MyEnum</c>
           may return either
          <c>MyEnum.Zero</c>
           or
          <c>MyEnum.Null</c>
           .) As a result, .NET Enum types with constants that share an
          underlying value should not be passed to this method.
        </item>
        <item>If the type is
          <c>byte[]</c>
           (a one-dimensional byte array) and this CBOR object is a byte string,
          returns a byte array which this CBOR byte string's data will be copied
          to. (This method can't be used to encode CBOR data to a byte array;
          for that, use the EncodeToBytes method instead.)
        </item>
        <item>If the type is a one-dimensional or multidimensional array type and
          this CBOR object is an array, returns an array containing the items in
          this CBOR object.
        </item>
        <item>If the type is List or the generic or non-generic IList, ICollection,
          or IEnumerable, (or ArrayList, List, Collection, or Iterable in Java),
          and if this CBOR object is an array, returns an object conforming to
          the type, class, or interface passed to this method, where the object
          will contain all items in this CBOR array.
        </item>
        <item>If the type is Dictionary or the generic or non-generic IDictionary
          (or HashMap or Map in Java), and if this CBOR object is a map, returns
          an object conforming to the type, class, or interface passed to this
          method, where the object will contain all keys and values in this CBOR
          map.
        </item>
        <item>If the type is an enumeration constant ("enum"), and this CBOR object
          is an integer or text string, returns the enumeration constant with
          the given number or name, respectively. (Enumeration constants made up
          of multiple enumeration constants, as allowed by .NET, can only be
          matched by number this way.)
        </item>
        <item>If the type is
          <c>DateTime</c>
           (or
          <c>Date</c>
           in Java) , returns a date/time object if the CBOR object's outermost
          tag is 0 or 1.
        </item>
        <item>If the type is
          <c>Uri</c>
           (or
          <c>URI</c>
           in Java), returns a URI object if possible.
        </item>
        <item>If the type is
          <c>Guid</c>
           (or
          <c>UUID</c>
           in Java), returns a UUID object if possible.
        </item>
        <item>Plain-Old-Data deserialization: If the object is a type not specially
          handled above, the type includes a zero-argument constructor (default
          or not), this CBOR object is a CBOR map, and the "mapper" parameter
          allows this type to be eligible for Plain-Old-Data deserialization,
          then this method checks the given type for eligible setters as
          follows:
        </item>
        <item>(*) In the .NET version, eligible setters are the public, nonstatic
          setters of properties with a public, nonstatic getter. If a class has
          two properties of the form "X" and "IsX", where "X" is any name, or
          has multiple properties with the same name, those properties are
          ignored.
        </item>
        <item>(*) In the Java version, eligible setters are public, nonstatic
          methods starting with "set" followed by a character other than a basic
          digit or lower-case letter, that is, other than "a" to "z" or "0" to
          "9", that take one parameter. The class containing an eligible setter
          must have a public, nonstatic method with the same name, but starting
          with "get" or "is" rather than "set", that takes no parameters and
          does not return void. (For example, if a class has "public
          setValue(String)" and "public getValue()", "setValue" is an eligible
          setter. However, "setValue()" and "setValue(String, int)" are not
          eligible setters.) If a class has two otherwise eligible setters with
          the same name, but different parameter type, they are not eligible
          setters.
        </item>
        <item>Then, the method creates an object of the given type and invokes each
          eligible setter with the corresponding value in the CBOR map, if any.
          Key names in the map are matched to eligible setters according to the
          rules described in the
          <see cref='T:PODOptions'/>
           documentation. Note that for security reasons, certain types are not
          supported even if they contain eligible setters.
        </item>
      </list>
      <para>REMARK: A certain consistency between .NET and Java and between
        FromObject and ToObject are sought for version 4.0. It is also hoped
        that--
      </para>
      <list>
        <item>the ToObject method will support deserializing to objects consisting
          of fields and not getters ("getX()" methods), both in .NET and in
          Java, and
        </item>
        <item>both FromObject and ToObject will be better designed, in version 4.0,
          so that backward-compatible improvements are easier to make.
        </item>
      </list>
    </summary>
    <param name='t'>The type, class, or interface that this method's return value will belong
      to. To express a generic type in Java, see the example.
      <b>Note:</b>
       For security reasons, an application should not base this parameter on
      user input or other externally supplied data. Whenever possible, this
      parameter should be either a type specially handled by this method (such
      as
      <c>int</c>
       or
      <c>String</c>
       ///) or a plain-old-data type (POCO or POJO type) within the control of
      the application. If the plain-old-data type references other data types,
      those types should likewise meet either criterion above.
    </param>
    <param name='mapper'>This parameter controls which data types are eligible for Plain-Old-Data
      deserialization and includes custom converters from CBOR objects to
      certain data types.
    </param>
    <param name='options'>Specifies options for controlling deserialization of CBOR objects.
    </param>
    <returns>The converted object.
    </returns>
    <exception cref='T:System.NotSupportedException'>The given type
      <paramref name='t'/>
       , or this object's CBOR type, is not supported.
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='t'/>
       is null.
    </exception>
    <exception cref='T:System.CBORException'>The given object's nesting is too deep, or another error occurred when
      serializing the object.
    </exception>
    <example><para>Java offers no easy way to express a generic type, at least none as easy
        as C#'s
        <c>typeof</c>
         operator. The following example, written in Java, is a way to specify
        that the return value will be an ArrayList of String objects.
      </para>
      <code>Type arrayListString = new ParameterizedType() { public Type[]
        getActualTypeArguments() { // Contains one type parameter, String return
        new Type[] { String.class }; } public Type getRawType() { /* Raw type is
        ArrayList */ return ArrayList.class; } public Type getOwnerType() {
        return null; } }; ArrayList&lt;String&gt; array =
        (ArrayList&lt;String&gt;) cborArray.ToObject(arrayListString);
      </code>
      <para>By comparison, the C# version is much shorter.
      </para>
      <code>var&#x20;array = (List&lt;String&gt;)cborArray.ToObject(
        typeof&#x28;List&lt;String&gt;));
      </code>
    </example>
</doc>
<doc name="M:CBORObject.ToObject(System.Type,PODOptions)">

            <summary>Converts this CBOR object to an object of an arbitrary
            type. See the documentation for the overload of this method taking
            a CBORTypeMapper and PODOptions parameters for more information. This method
            (without a CBORTypeMapper parameter) allows all data types not
            otherwise handled to be eligible for Plain-Old-Data
            serialization.</summary><param name='t'>The type, class, or interface that this method's
            return value will belong to. To express a generic type in Java, see
            the example. <b>Note:</b>
             For security reasons, an application
            should not base this parameter on user input or other externally
            supplied data. Whenever possible, this parameter should be either a
            type specially handled by this method (such as <c>int</c>
             or
            <c>String</c>
             ///) or a plain-old-data type (POCO or POJO type)
            within the control of the application. If the plain-old-data type
            references other data types, those types should likewise meet
            either criterion above.</param><param name='options'>Specifies options for controlling deserialization of CBOR objects.
    </param><returns>The converted object.</returns><exception cref='T:System.NotSupportedException'>The given type
            <paramref name='t'/> , or this object's CBOR type, is not
            supported.</exception><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='t'/> is null.</exception><exception cref='T:System.CBORException'>The given object's nesting
            is too deep, or another error occurred when serializing the
            object.</exception>

</doc>
<doc name="M:CBORObject.ToObject``1">

            <summary><para>Converts this CBOR object to an object of an arbitrary type.  See <see cref='M:CBORObject.ToObject(System.Type)'/> for further information.</para>
</summary><typeparam name='T'>The type, class, or interface that this method's return value will belong
      to. <b>Note:</b> For security reasons,
      an application should not base this parameter on user input or other externally supplied
      data.  Whenever possible, this parameter should be either a type specially handled by
      this method (such as <c>int</c> or <c>String</c>) or a plain-old-data type
      (POCO type) within the control of the application.  If the plain-old-data
      type references other data types, those types should likewise meet either criterion above.</typeparam><returns>The converted object.</returns><exception cref='T:System.NotSupportedException'>The given type "T", or this object's CBOR type, is not supported.
    </exception>

</doc>
<doc name="M:CBORObject.ToObject``1(CBORTypeMapper)">

            <summary><para>Converts this CBOR object to an object of an arbitrary type.
            See
            <see cref='M:CBORObject.ToObject(System.Type)'/> for
            further information.</para></summary><param name='mapper'>This parameter controls which data types are eligible for Plain-Old-Data
      deserialization and includes custom converters from CBOR objects to
      certain data types.
    </param><typeparam name='T'>The type, class, or interface that this
            method's return value will belong to. <b>Note:</b> For security
            reasons, an application should not base this parameter on user
            input or other externally supplied data. Whenever possible, this
            parameter should be either a type specially handled by this method
            (such as <c>int</c> or <c>String</c> ) or a plain-old-data type
            (POCO type) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</typeparam><returns>The converted object.</returns><exception cref='T:System.NotSupportedException'>The given type
            "T", or this object's CBOR type, is not supported.</exception>

</doc>
<doc name="M:CBORObject.ToObject``1(CBORTypeMapper,PODOptions)">

            <summary><para>Converts this CBOR object to an object of an arbitrary type.
            See
            <see cref='M:CBORObject.ToObject(System.Type)'/> for
            further information.</para></summary><param name='mapper'>This parameter controls which data types are eligible for Plain-Old-Data
      deserialization and includes custom converters from CBOR objects to
      certain data types.
    </param><param name='options'>Specifies options for controlling deserialization of CBOR objects.
    </param><typeparam name='T'>The type, class, or interface that this
            method's return value will belong to. <b>Note:</b> For security
            reasons, an application should not base this parameter on user
            input or other externally supplied data. Whenever possible, this
            parameter should be either a type specially handled by this method
            (such as <c>int</c> or <c>String</c> ) or a plain-old-data type
            (POCO type) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</typeparam><returns>The converted object.</returns><exception cref='T:System.NotSupportedException'>The given type
            "T", or this object's CBOR type, is not supported.</exception>

</doc>
<doc name="M:CBORObject.ToObject``1(PODOptions)">

            <summary><para>Converts this CBOR object to an object of an arbitrary type.
            See
            <see cref='M:CBORObject.ToObject(System.Type)'/> for
            further information.</para></summary><param name='options'>Specifies options for controlling deserialization of CBOR objects.
    </param><typeparam name='T'>The type, class, or interface that this
            method's return value will belong to. <b>Note:</b> For security
            reasons, an application should not base this parameter on user
            input or other externally supplied data. Whenever possible, this
            parameter should be either a type specially handled by this method
            (such as <c>int</c> or <c>String</c> ) or a plain-old-data type
            (POCO type) within the control of the application. If the
            plain-old-data type references other data types, those types should
            likewise meet either criterion above.</typeparam><returns>The converted object.</returns><exception cref='T:System.NotSupportedException'>The given type
            "T", or this object's CBOR type, is not supported.</exception>

</doc>
<doc name="M:CBORObject.ToString">

            <summary>Returns this CBOR object in string form. The format is intended to be
      human-readable, not machine-readable, the format is not intended to be
      parsed, and the format may change at any time.  The returned string
is not necessarily in JavaScript Object Notation (JSON); to convert
CBOR objects to JSON strings, use the <see cref='M:CBORObject.ToJSONString(JSONOptions)'/> method instead.
    </summary><returns>A text representation of this object.
    </returns>

</doc>
<doc name="F:CBORObject.True">

            <summary>Represents the value true.
    </summary>

</doc>
<doc name="P:CBORObject.Type">

            <summary>Gets the general data type of this CBOR object.
    </summary><value>The general data type of this CBOR object.
    </value>

</doc>
<doc name="F:CBORObject.Undefined">

            <summary>Represents the value undefined.
    </summary>

</doc>
<doc name="M:CBORObject.Untag">

            <summary>Gets an object with the same value as this one but without the tags it
      has, if any. If this object is an array, map, or byte string, the data
      will not be copied to the returned object, so changes to the returned
      object will be reflected in this one.
    </summary><returns>A CBORObject object.
    </returns>

</doc>
<doc name="M:CBORObject.UntagOne">

            <summary>Gets an object with the same value as this one but without this object's
      outermost tag, if any. If this object is an array, map, or byte string,
      the data will not be copied to the returned object, so changes to the
      returned object will be reflected in this one.
    </summary><returns>A CBORObject object.
    </returns>

</doc>
<doc name="P:CBORObject.Values">

            <summary>Gets a collection of the values of this CBOR object, if
            it's a map or an array. If this object is a map, returns one value
            for each key in the map in an undefined order. If this is an array,
            returns all the values of the array in the order they are listed.
            (This method can't be used to get the bytes in a CBOR byte string;
            for that, use the GetByteArray method instead.).</summary><value>A collection of the values of this CBOR map or
            array.</value><exception cref='T:System.InvalidOperationException'>This object is
            not a map or an array.</exception>

</doc>
<doc name="M:CBORObject.Write(PeterO.BigInteger,System.IO.Stream)">

            <summary>Writes a big integer in CBOR format to a data
            stream.</summary><param name='bigint'>Big integer to write. Can be null.</param><param name='stream'>A writable data stream.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(CBORObject,System.IO.Stream)">

            <summary>Writes a CBOR object to a CBOR data stream.</summary><param name='value'>The value to write. Can be null.</param><param name='stream'>A writable data stream.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception>

</doc>
<doc name="M:CBORObject.Write(PeterO.ExtendedDecimal,System.IO.Stream)">

            <summary>Writes a decimal floating-point number in CBOR format to a
            data stream, as follows:
            <list type=''>
            <item>If the value is null, writes the byte 0xF6.</item>
            <item>If the value is negative zero, infinity, or NaN, converts the
            number to a <c>double</c> and writes that <c>double</c>. If
            negative zero should not be written this way, use the Plus method
            to convert the value beforehand.</item>
            <item>If the value has an exponent of zero, writes the value as an
            unsigned integer or signed integer if the number can fit either
            type or as a big integer otherwise.</item>
            <item>In all other cases, writes the value as a decimal
            number.</item></list></summary><param name='bignum'>The arbitrary-precision decimal number to
            write. Can be null.</param><param name='stream'>Stream to write to.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(PeterO.ExtendedFloat,System.IO.Stream)">

            <summary>Writes a binary floating-point number in CBOR format to a
            data stream as follows:
            <list type=''>
            <item>If the value is null, writes the byte 0xF6.</item>
            <item>If the value is negative zero, infinity, or NaN, converts the
            number to a <c>double</c> and writes that <c>double</c>. If
            negative zero should not be written this way, use the Plus method
            to convert the value beforehand.</item>
            <item>If the value has an exponent of zero, writes the value as an
            unsigned integer or signed integer if the number can fit either
            type or as a big integer otherwise.</item>
            <item>In all other cases, writes the value as a big
            float.</item></list></summary><param name='bignum'>An arbitrary-precision binary float.</param><param name='stream'>A writable data stream.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(PeterO.ExtendedRational,System.IO.Stream)">

            <summary>Writes a rational number in CBOR format to a data
            stream.</summary><param name='rational'>An arbitrary-precision rational
            number.</param><param name='stream'>A writable data stream.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(PeterO.Numbers.EDecimal,System.IO.Stream)">

            <summary>Writes a decimal floating-point number in CBOR format to a
            data stream, as follows:
            <list type=''>
            <item>If the value is null, writes the byte 0xF6.</item>
            <item>If the value is negative zero, infinity, or NaN, converts the
            number to a <c>double</c> and writes that <c>double</c>. If
            negative zero should not be written this way, use the Plus method
            to convert the value beforehand.</item>
            <item>If the value has an exponent of zero, writes the value as an
            unsigned integer or signed integer if the number can fit either
            type or as a big integer otherwise.</item>
            <item>In all other cases, writes the value as a decimal
            number.</item></list></summary><param name='bignum'>The arbitrary-precision decimal number to
            write. Can be null.</param><param name='stream'>Stream to write to.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(PeterO.Numbers.EFloat,System.IO.Stream)">

            <summary>Writes a binary floating-point number in CBOR format to a
            data stream as follows:
            <list type=''>
            <item>If the value is null, writes the byte 0xF6.</item>
            <item>If the value is negative zero, infinity, or NaN, converts the
            number to a <c>double</c> and writes that <c>double</c>. If
            negative zero should not be written this way, use the Plus method
            to convert the value beforehand.</item>
            <item>If the value has an exponent of zero, writes the value as an
            unsigned integer or signed integer if the number can fit either
            type or as a big integer otherwise.</item>
            <item>In all other cases, writes the value as a big
            float.</item></list></summary><param name='bignum'>An arbitrary-precision binary float.</param><param name='stream'>A writable data stream.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(PeterO.Numbers.EInteger,System.IO.Stream)">

            <summary>Writes a big integer in CBOR format to a data
            stream.</summary><param name='bigint'>Big integer to write. Can be null.</param><param name='stream'>A writable data stream.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(PeterO.Numbers.ERational,System.IO.Stream)">

            <summary>Writes a rational number in CBOR format to a data
            stream.</summary><param name='rational'>An arbitrary-precision rational
            number.</param><param name='stream'>A writable data stream.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(System.Boolean,System.IO.Stream)">

            <summary>Writes a Boolean value in CBOR format to a data
            stream.</summary><param name='value'>The value to write.</param><param name='stream'>A writable data stream.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(System.Byte,System.IO.Stream)">

            <summary>Writes a byte (0 to 255) in CBOR format to a data stream.
            If the value is less than 24, writes that byte. If the value is 25
            to 255, writes the byte 24, then this byte's value.</summary><param name='value'>The value to write.</param><param name='stream'>A writable data stream.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(System.Char,System.IO.Stream)">

            <summary>Writes a Unicode character as a string in CBOR format to a
            data stream.</summary><param name='value'>The value to write.</param><param name='stream'>A writable data stream.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.ArgumentException'>The parameter
            <paramref name='value'/> is a surrogate code point.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception><remarks>Note that this method's behavior may change in the future.
            Currently, it converts ' char's to text strings, but it may change
            to convert them to integers instead.</remarks>

</doc>
<doc name="M:CBORObject.Write(System.Double,System.IO.Stream)">

            <summary>Writes a 64-bit floating-point number in CBOR format to a
            data stream.</summary><param name='value'>The value to write.</param><param name='stream'>A writable data stream.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(System.Int16,System.IO.Stream)">

            <summary>Writes a 16-bit signed integer in CBOR format to a data
            stream.</summary><param name='value'>The value to write.</param><param name='stream'>A writable data stream.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(System.Int32,System.IO.Stream)">

            <summary>Writes a 32-bit signed integer in CBOR format to a data
            stream.</summary><param name='value'>The value to write.</param><param name='stream'>A writable data stream.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(System.Int64,System.IO.Stream)">

            <summary>Writes a 64-bit signed integer in CBOR format to a data
            stream.</summary><param name='value'>The value to write.</param><param name='stream'>A writable data stream.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(System.Object,System.IO.Stream)">

            <summary><para><b>At the moment, use the overload of this method that takes a
          <see cref='T:CBOREncodeOptions'/>
           object. The object
          <c>CBOREncodeOptions.Default</c>
           contains recommended settings for CBOREncodeOptions, and those
          settings may be adopted by this overload (without a CBOREncodeOptions
          argument) in the next major version.</b>
      </para>
      <para>Writes a CBOR object to a CBOR data stream. See the three-parameter
        Write method that takes a CBOREncodeOptions.
      </para>
    </summary><param name='objValue'>The parameter
      <paramref name='objValue'/>
       is an arbitrary object.
    </param><param name='stream'>A writable data stream.
    </param>

</doc>
<doc name="M:CBORObject.Write(System.Object,System.IO.Stream,CBOREncodeOptions)">

            <summary>Writes an arbitrary object to a CBOR data stream, using
            the specified options for controlling how the object is encoded to
            CBOR data format. If the object is convertible to a CBOR map or a
            CBOR object that contains CBOR maps, the keys to those maps are
            written out to the data stream in an undefined order. The example
            code given in
            <see cref='M:CBORObject.WriteTo(System.IO.Stream)'/>
            can be used to write out certain keys of a CBOR map in a given
            order. Currently, the following objects are supported:
            <list type=''>
            <item>Lists of CBORObject.</item>
            <item>Maps of CBORObject. The keys to the map are written out to
            the data stream in an undefined order.</item>
            <item>Null.</item>
            <item>Byte arrays, which will always be written as definite-length
            byte strings.</item>
            <item>String objects, which will be written as indefinite-length
            text strings if their size exceeds a certain threshold (this
            behavior may change in future versions of this library).</item>
            <item>Any object accepted by the FromObject static
            methods.</item></list></summary><param name='objValue'>The arbitrary object to be serialized. Can
            be null.</param><param name='output'>A writable data stream.</param><param name='options'>CBOR options for encoding the CBOR object to
            bytes.</param><exception cref='T:System.ArgumentException'>The object's type is
            not supported.</exception><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='options'/> or <paramref name='output'/> is
            null.</exception>

</doc>
<doc name="M:CBORObject.Write(System.SByte,System.IO.Stream)">

            <summary>Writes an 8-bit signed integer in CBOR format to a data stream.
    </summary><param name='value'>The parameter
      <paramref name='value'/>
       is an 8-bit signed integer.
    </param><param name='stream'>A writable data stream.
    </param>

</doc>
<doc name="M:CBORObject.Write(System.Single,System.IO.Stream)">

            <summary>Writes a 32-bit floating-point number in CBOR format to a
            data stream.</summary><param name='value'>The value to write.</param><param name='s'>A writable data stream.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='s'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(System.String,System.IO.Stream)">

            <summary><para><b>At the moment, use the overload of this method that takes
            a
            <see cref='T:CBOREncodeOptions'/> object. The object
            <c>CBOREncodeOptions.Default</c> contains recommended settings for
            CBOREncodeOptions, and those settings may be adopted by this
            overload (without a CBOREncodeOptions argument) in the next major
            version.</b></para>
            <para>Writes a string in CBOR format to a data stream. The string
            will be encoded using indefinite-length encoding if its length
            exceeds a certain threshold (this behavior may change in future
            versions of this library).</para></summary><param name='str'>The string to write. Can be null.</param><param name='stream'>A writable data stream.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(System.String,System.IO.Stream,CBOREncodeOptions)">

            <summary>Writes a string in CBOR format to a data stream, using the
            given options to control the encoding process.</summary><param name='str'>The string to write. Can be null.</param><param name='stream'>A writable data stream.</param><param name='options'>Options for encoding the data to
            CBOR.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception>

</doc>
<doc name="M:CBORObject.Write(System.UInt16,System.IO.Stream)">

            <summary>Writes a 16-bit unsigned integer in CBOR format to a data stream.
    </summary><param name='value'>A 16-bit unsigned integer.
    </param><param name='stream'>A writable data stream.
    </param>

</doc>
<doc name="M:CBORObject.Write(System.UInt32,System.IO.Stream)">

            <summary>Writes a 32-bit unsigned integer in CBOR format to a data stream.
    </summary><param name='value'>A 32-bit unsigned integer.
    </param><param name='stream'>A writable data stream.
    </param>

</doc>
<doc name="M:CBORObject.Write(System.UInt64,System.IO.Stream)">

            <summary>Writes a 64-bit unsigned integer in CBOR format to a data stream.
    </summary><param name='value'>A 64-bit unsigned integer.
    </param><param name='stream'>A writable data stream.
    </param><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>

</doc>
<doc name="M:CBORObject.WriteJSON(System.Object,System.IO.Stream)">

            <summary>Converts an arbitrary object to a string in JavaScript Object Notation
      (JSON) format, as in the ToJSONString method, and writes that string to a
      data stream in UTF-8. If the object is convertible to a CBOR map, or to a
      CBOR object that contains CBOR maps, the keys to those maps are written
      out to the JSON string in an undefined order. The example code given in
      <see cref='M:CBORObject.ToJSONString(JSONOptions)'/>
       can be used to write out certain keys of a CBOR map in a given order to a
      JSON string.
    </summary><param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param><param name='outputStream'>A writable data stream.
    </param>

</doc>
<doc name="M:CBORObject.WriteJSONTo(System.IO.Stream)">

            <summary>Converts this object to a string in JavaScript Object
            Notation (JSON) format, as in the ToJSONString method, and writes
            that string to a data stream in UTF-8. If the CBOR object contains
            CBOR maps, or is a CBOR map, the keys to the map are written out to
            the JSON string in an undefined order. The example code given in
            <see cref='M:CBORObject.ToJSONString(JSONOptions)'/>
            can be used to write out certain keys of a CBOR map in a given
            order to a JSON string.</summary><param name='outputStream'>A writable data stream.</param><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='outputStream'/> is null.</exception>

</doc>
<doc name="M:CBORObject.WriteJSONTo(System.IO.Stream,JSONOptions)">

            <summary>Converts this object to a string in JavaScript Object
            Notation (JSON) format, as in the ToJSONString method, and writes
            that string to a data stream in UTF-8, using the given JSON options
            to control the encoding process. If the CBOR object contains CBOR
            maps, or is a CBOR map, the keys to the map are written out to the
            JSON string in an undefined order. The example code given in
            <see cref='M:CBORObject.ToJSONString(JSONOptions)'/>
            can be used to write out certain keys of a CBOR map in a given
            order to a JSON string.</summary><param name='outputStream'>A writable data stream.</param><param name='options'>An object containing the options to control
            writing the CBOR object to JSON.</param><exception cref='T:System.IO.IOException'>An I/O error
            occurred.</exception><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='outputStream'/> is null.</exception>

</doc>
<doc name="M:CBORObject.WriteTo(System.IO.Stream)">
<summary><para><b>At the moment, use the overload of this method that takes a
          <see cref='T:CBOREncodeOptions'/>
           object. The object
          <c>CBOREncodeOptions.Default</c>
           contains recommended settings for CBOREncodeOptions, and those
          settings may be adopted by this overload (without a CBOREncodeOptions
          argument) in the next major version.</b>
      </para>
      <para>Writes this CBOR object to a data stream. If the CBOR object contains
        CBOR maps, or is a CBOR map, the keys to the map are written out to the
        data stream in an undefined order. See the examples (written in C# for
        the .NET version) for ways to write out certain keys of a CBOR map in a
        given order.
      </para>
    </summary>
    <param name='stream'>A writable data stream.
    </param>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>
    <exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>
    <example><para>The following example shows a method that writes each key of 'mapObj' to
        'outputStream', in the order given in 'keys', where 'mapObj' is written
        out in the form of a CBOR
        <b>definite-length map</b>
         . Only keys found in 'keys' will be written if they exist in 'mapObj'.
      </para>
      <code>private static void WriteKeysToMap&#x28;CBORObject mapObj,
        IList&lt;CBORObject&gt; keys, Stream outputStream)&#x7b; if&#x28;mapObj
        == null)&#x7b; throw new
        ArgumentNullException&#x28;nameof(mapObj));&#x7d; if&#x28;keys ==
        null)&#x7b;throw new ArgumentNullException&#x28;nameof(keys));&#x7d;
        if&#x28;outputStream == null)&#x7b;throw new
        ArgumentNullException&#x28;nameof(outputStream));&#x7d;
        if&#x28;obj.Type!=CBORType.Map)&#x7b; throw new ArgumentException("'obj'
        is not a map."); &#x7d; int keyCount = 0; for (CBORObject key in keys)
        &#x7b; if&#x28;mapObj.ContainsKey(key))&#x7b; keyCount++; &#x7d; &#x7d;
        CBORObject.WriteValue(outputStream, 5, keyCount); for (CBORObject key in
        keys) &#x7b; if&#x28;mapObj.ContainsKey(key))&#x7b;
        key.WriteTo(outputStream); mapObj[key].WriteTo(outputStream); &#x7d;
        &#x7d; &#x7d;
      </code>
      <para>The following example shows a method that writes each key of 'mapObj' to
        'outputStream', in the order given in 'keys', where 'mapObj' is written
        out in the form of a CBOR
        <b>indefinite-length map</b>
         . Only keys found in 'keys' will be written if they exist in 'mapObj'.
      </para>
      <code>private static void WriteKeysToIndefMap&#x28;CBORObject mapObj,
        IList&lt;CBORObject&gt; keys, Stream outputStream)&#x7b; if&#x28;mapObj
        == null)&#x7b; throw new
        ArgumentNullException&#x28;nameof(mapObj));&#x7d; if&#x28;keys ==
        null)&#x7b;throw new ArgumentNullException&#x28;nameof(keys));&#x7d;
        if&#x28;outputStream == null)&#x7b;throw new
        ArgumentNullException&#x28;nameof(outputStream));&#x7d;
        if&#x28;obj.Type!=CBORType.Map)&#x7b; throw new ArgumentException("'obj'
        is not a map."); &#x7d; outputStream.WriteByte((byte)0xBF); for
        (CBORObject key in keys) &#x7b; if&#x28;mapObj.ContainsKey(key))&#x7b;
        key.WriteTo(outputStream); mapObj[key].WriteTo(outputStream); &#x7d;
        &#x7d; outputStream.WriteByte((byte)0xff); &#x7d;
      </code>
      <para>The following example shows a method that writes out a list of objects
        to 'outputStream' as an
        <b>indefinite-length CBOR array</b>
         .
      </para>
      <code>private static void WriteToIndefArray&#x28; IList&lt;object&gt; list,
        Stream outputStream)&#x7b; if&#x28;list == null)&#x7b; throw new
        ArgumentNullException&#x28;nameof(list));&#x7d; if&#x28;outputStream ==
        null)&#x7b;throw new
        ArgumentNullException&#x28;nameof(outputStream));&#x7d;
        outputStream.WriteByte((byte)0x9f); for (object item in list) &#x7b; new
        CBORObject(item).WriteTo(outputStream); &#x7d;
        outputStream.WriteByte((byte)0xff); &#x7d;
      </code>
    </example>
</doc>
<doc name="M:CBORObject.WriteTo(System.IO.Stream,CBOREncodeOptions)">

            <summary>Writes this CBOR object to a data stream, using the
             specified options for encoding the data to CBOR format. If the CBOR
             object contains CBOR maps, or is a CBOR map, the keys to the map
             are written out to the data stream in an undefined order. The
             example code given in
             <see cref='M:CBORObject.WriteTo(System.IO.Stream)'/>
             can be used to write out certain keys of a CBOR map in a given
             order.</summary><param name='stream'>A writable data stream.</param><param name='options'>Options for encoding the data to
             CBOR.</param><exception cref='T:System.ArgumentNullException'>The parameter
             <paramref name='stream'/> is null.</exception><exception cref='T:System.IO.IOException'>An I/O error
             occurred.</exception><exception cref='T:System.ArgumentException'>"Unexpected data
             type".</exception>

</doc>
<doc name="M:CBORObject.WriteValue(System.IO.Stream,System.Int32,PeterO.Numbers.EInteger)">

            <summary>Writes a CBOR major type number and an integer 0 or
            greater associated with it to a data stream, where that integer is
            passed to this method as an arbitrary-precision integer. This is a
            low-level method that is useful for implementing custom CBOR
            encoding methodologies. This method encodes the given major type
            and value in the shortest form allowed for the major
            type.</summary><param name='outputStream'>A writable data stream.</param><param name='majorType'>The CBOR major type to write. This is a
            number from 0 through 7 as follows. 0: integer 0 or greater; 1:
            negative integer; 2: byte string; 3: UTF-8 text string; 4: array;
            5: map; 6: tag; 7: simple value. See RFC 7049 for details on these
            major types.</param><param name='bigintValue'>An integer 0 or greater associated with
            the major type, as follows. 0: integer 0 or greater; 1: the
            negative integer's absolute value is 1 plus this number; 2: length
            in bytes of the byte string; 3: length in bytes of the UTF-8 text
            string; 4: number of items in the array; 5: number of key-value
            pairs in the map; 6: tag number; 7: simple value number, which must
            be in the interval [0, 23] or [32, 255]. For major types 0 to 6,
            this number may not be greater than 2^64 - 1.</param><returns>The number of bytes ordered to be written to the data
            stream.</returns><exception cref='T:System.ArgumentException'>The parameter
            <paramref name='majorType'/> is 7 and value is greater than
            255.</exception><exception cref='T:System.ArgumentNullException'>The parameter <paramref name='outputStream'/> or <paramref name='bigintValue'/> is
            null.</exception>

</doc>
<doc name="M:CBORObject.WriteValue(System.IO.Stream,System.Int32,System.Int32)">

            <summary>Writes a CBOR major type number and an integer 0 or
            greater associated with it to a data stream, where that integer is
            passed to this method as a 32-bit signed integer. This is a
            low-level method that is useful for implementing custom CBOR
            encoding methodologies. This method encodes the given major type
            and value in the shortest form allowed for the major
            type.</summary><param name='outputStream'>A writable data stream.</param><param name='majorType'>The CBOR major type to write. This is a
            number from 0 through 7 as follows. 0: integer 0 or greater; 1:
            negative integer; 2: byte string; 3: UTF-8 text string; 4: array;
            5: map; 6: tag; 7: simple value. See RFC 7049 for details on these
            major types.</param><param name='value'>An integer 0 or greater associated with the
            major type, as follows. 0: integer 0 or greater; 1: the negative
            integer's absolute value is 1 plus this number; 2: length in bytes
            of the byte string; 3: length in bytes of the UTF-8 text string; 4:
            number of items in the array; 5: number of key-value pairs in the
            map; 6: tag number; 7: simple value number, which must be in the
            interval [0, 23] or [32, 255].</param><returns>The number of bytes ordered to be written to the data
            stream.</returns><exception cref='T:System.ArgumentException'>Value is from 24 to 31
            and major type is 7.</exception><exception cref='T:System.ArgumentNullException'>The parameter <paramref name='outputStream'/> is null.</exception><example><para>In the following example, an array of three objects is
            written as CBOR to a data stream.</para>
            <code>CBORObject.WriteValue(stream, 4, 3);  /* array, length 3 */
            CBORObject.Write("hello world", stream);  /* item 1 */
            CBORObject.Write(25, stream);  /* item 2 */
            CBORObject.Write(false, stream);  // item 3
            </code>
            <para>In the following example, a map consisting of two key-value
            pairs is written as CBOR to a data stream.</para>
            <code>CBORObject.WriteValue(stream, 5, 2);  // map, 2 pairs
            CBORObject.Write("number", stream);  // key 1
            CBORObject.Write(25, stream);  // value 1
            CBORObject.Write("string", stream);  // key 2
            CBORObject.Write("hello", stream);  // value 2
            </code>
<para>In the following example (originally written in C# for the .NET Framework version), a text string is written as CBOR to a data stream.</para>
<code>string str = "hello world";
byte[] bytes = DataUtilities.GetUtf8Bytes(str, true);
CBORObject.WriteValue(stream, 4, bytes.Length);
stream.Write(bytes, 0, bytes.Length);
</code>
            </example>

</doc>
<doc name="M:CBORObject.WriteValue(System.IO.Stream,System.Int32,System.Int64)">

            <summary>Writes a CBOR major type number and an integer 0 or
            greater associated with it to a data stream, where that integer is
            passed to this method as a 64-bit signed integer. This is a
            low-level method that is useful for implementing custom CBOR
            encoding methodologies. This method encodes the given major type
            and value in the shortest form allowed for the major
            type.</summary><param name='outputStream'>A writable data stream.</param><param name='majorType'>The CBOR major type to write. This is a
            number from 0 through 7 as follows. 0: integer 0 or greater; 1:
            negative integer; 2: byte string; 3: UTF-8 text string; 4: array;
            5: map; 6: tag; 7: simple value. See RFC 7049 for details on these
            major types.</param><param name='value'>An integer 0 or greater associated with the
            major type, as follows. 0: integer 0 or greater; 1: the negative
            integer's absolute value is 1 plus this number; 2: length in bytes
            of the byte string; 3: length in bytes of the UTF-8 text string; 4:
            number of items in the array; 5: number of key-value pairs in the
            map; 6: tag number; 7: simple value number, which must be in the
            interval [0, 23] or [32, 255].</param><returns>The number of bytes ordered to be written to the data
            stream.</returns><exception cref='T:System.ArgumentException'>Value is from 24 to 31
            and major type is 7.</exception><exception cref='T:System.ArgumentNullException'>The parameter <paramref name='outputStream'/> is null.</exception>

</doc>
<doc name="M:CBORObject.WriteValue(System.IO.Stream,System.Int32,System.UInt32)">

            <summary>Writes a CBOR major type number and an integer 0 or
            greater associated with it to a data stream, where that integer is
            passed to this method as a 32-bit unsigned integer. This is a
            low-level method that is useful for implementing custom CBOR
            encoding methodologies. This method encodes the given major type
            and value in the shortest form allowed for the major
            type.</summary><param name='outputStream'>A writable data stream.</param><param name='majorType'>The CBOR major type to write. This is a
            number from 0 through 7 as follows. 0: integer 0 or greater; 1:
            negative integer; 2: byte string; 3: UTF-8 text string; 4: array;
            5: map; 6: tag; 7: simple value. See RFC 7049 for details on these
            major types.</param><param name='value'>An integer 0 or greater associated with the
            major type, as follows. 0: integer 0 or greater; 1: the negative
            integer's absolute value is 1 plus this number; 2: length in bytes
            of the byte string; 3: length in bytes of the UTF-8 text string; 4:
            number of items in the array; 5: number of key-value pairs in the
            map; 6: tag number; 7: simple value number, which must be in the
            interval [0, 23] or [32, 255].</param><returns>The number of bytes ordered to be written to the data
            stream.</returns><exception cref='T:System.ArgumentNullException'>The parameter <paramref name='outputStream'/> is null.</exception>

</doc>
<doc name="M:CBORObject.WriteValue(System.IO.Stream,System.Int32,System.UInt64)">

            <summary>Writes a CBOR major type number and an integer 0 or
            greater associated with it to a data stream, where that integer is
            passed to this method as a 64-bit unsigned integer. This is a
            low-level method that is useful for implementing custom CBOR
            encoding methodologies. This method encodes the given major type
            and value in the shortest form allowed for the major
            type.</summary><param name='outputStream'>A writable data stream.</param><param name='majorType'>The CBOR major type to write. This is a
            number from 0 through 7 as follows. 0: integer 0 or greater; 1:
            negative integer; 2: byte string; 3: UTF-8 text string; 4: array;
            5: map; 6: tag; 7: simple value. See RFC 7049 for details on these
            major types.</param><param name='value'>An integer 0 or greater associated with the
            major type, as follows. 0: integer 0 or greater; 1: the negative
            integer's absolute value is 1 plus this number; 2: length in bytes
            of the byte string; 3: length in bytes of the UTF-8 text string; 4:
            number of items in the array; 5: number of key-value pairs in the
            map; 6: tag number; 7: simple value number, which must be in the
            interval [0, 23] or [32, 255].</param><returns>The number of bytes ordered to be written to the data
            stream.</returns><exception cref='T:System.ArgumentException'>The parameter
            <paramref name='majorType'/> is 7 and value is greater than
            255.</exception><exception cref='T:System.ArgumentNullException'>The parameter <paramref name='outputStream'/> is null.</exception>

</doc>
<doc name="F:CBORObject.Zero">

            <summary>Gets a CBOR object for the number zero.
    </summary>

</doc>
<doc name="M:CBORObject.op_Addition(CBORObject,CBORObject)">

            <summary>Adds two CBOR objects and returns their result.
    </summary><param name='a'>The parameter
      <paramref name='a'/>
       is a CBOR object.
    </param><param name='b'>The parameter
      <paramref name='b'/>
       is a CBOR object.
    </param><returns>The sum of the two objects.
    </returns>

</doc>
<doc name="M:CBORObject.op_Division(CBORObject,CBORObject)">

            <summary>Divides a CBORObject object by the value of a CBORObject object.
    </summary><param name='a'>The parameter
      <paramref name='a'/>
       is a CBOR object.
    </param><param name='b'>The parameter
      <paramref name='b'/>
       is a CBOR object.
    </param><returns>The quotient of the two objects.
    </returns>

</doc>
<doc name="M:CBORObject.op_Modulus(CBORObject,CBORObject)">

            <summary>Finds the remainder that results when a CBORObject object is divided by
      the value of a CBORObject object.
    </summary><param name='a'>The parameter
      <paramref name='a'/>
       is a CBOR object.
    </param><param name='b'>The parameter
      <paramref name='b'/>
       is a CBOR object.
    </param><returns>The remainder of the two numbers.
    </returns>

</doc>
<doc name="M:CBORObject.op_Multiply(CBORObject,CBORObject)">

            <summary>Multiplies a CBORObject object by the value of a CBORObject object.
    </summary><param name='a'>The parameter
      <paramref name='a'/>
       is a CBOR object.
    </param><param name='b'>The parameter
      <paramref name='b'/>
       is a CBOR object.
    </param><returns>The product of the two numbers.
    </returns>

</doc>
<doc name="M:CBORObject.op_Subtraction(CBORObject,CBORObject)">

            <summary>Subtracts a CBORObject object from a CBORObject object.
    </summary><param name='a'>The parameter
      <paramref name='a'/>
       is a CBOR object.
    </param><param name='b'>The parameter
      <paramref name='b'/>
       is a CBOR object.
    </param><returns>The difference of the two objects.
    </returns>

</doc>
<doc name="T:CBORObjectMath">

            <summary>Implements arithmetic operations with CBOR objects.
    </summary>

</doc>
<doc name="T:CBORTag3">

            <summary>Implements CBOR tag 3.
    </summary>

</doc>
<doc name="M:CBORTag37.ToCBORObject(System.Guid)">

            <summary>Converts a UUID to a CBOR object.
    </summary><param name='obj'>A UUID.
    </param><returns>A CBORObject object.
    </returns>

</doc>
<doc name="T:CBORTagGenericString">

            <summary>A generic CBOR tag class for strings.
    </summary>

</doc>
<doc name="T:CBORType">

            <summary>Represents a type that a CBOR object can have.
    </summary>

</doc>
<doc name="F:CBORType.Array">

            <summary>An array of CBOR objects.
    </summary>

</doc>
<doc name="F:CBORType.Boolean">

            <summary>The simple values true and false.
    </summary>

</doc>
<doc name="F:CBORType.ByteString">

            <summary>An array of bytes.
    </summary>

</doc>
<doc name="F:CBORType.Map">

            <summary>A map of CBOR objects.
    </summary>

</doc>
<doc name="F:CBORType.Number">

            <summary>A number of any kind, including integers, big integers, floating point
      numbers, and decimal numbers. The floating-point value Not-a-Number is
      also included in the Number type.
    </summary>

</doc>
<doc name="F:CBORType.SimpleValue">

            <summary>A "simple value" other than floating point values, true, and false.
    </summary>

</doc>
<doc name="F:CBORType.TextString">

            <summary>A text string.
    </summary>

</doc>
<doc name="T:CBORTypeFilter">

            <summary>Specifies what kinds of CBOR objects a tag can be. This class is used
      when a CBOR object is being read from a data stream. This class can't be
      inherited; this is a change in version 2.0 from previous versions, where
      the class was inadvertently left inheritable.
    </summary>

</doc>
<doc name="F:CBORTypeFilter.Any">

            <summary>A filter that allows any CBOR object.
    </summary>

</doc>
<doc name="M:CBORTypeFilter.ArrayIndexAllowed(System.Int32)">

            <summary>Determines whether this type filter allows CBOR arrays and the given
      array index is allowed under this type filter.
    </summary><param name='index'>An array index, starting from 0.
    </param><returns><c>true</c>
       if this type filter allows CBOR arrays and the given array index is
      allowed under this type filter; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:CBORTypeFilter.ArrayLengthMatches(PeterO.Numbers.EInteger)">

            <summary>Returns whether an array's length is allowed under a filter.
    </summary><param name='bigLength'>An arbitrary-precision integer.
    </param><returns><c>true</c>
       if this filter allows CBOR arrays and an array's length is allowed under
      a filter; otherwise, <c>false</c>
       .
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigLength'/>
       is null.
    </exception>

</doc>
<doc name="M:CBORTypeFilter.ArrayLengthMatches(System.Int32)">

            <summary>Returns whether an array's length is allowed under this filter.
    </summary><param name='length'>The length of a CBOR array.
    </param><returns><c>true</c>
       if this filter allows CBOR arrays and an array's length is allowed under
      this filter; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:CBORTypeFilter.ArrayLengthMatches(System.Int64)">

            <summary>Returns whether an array's length is allowed under a filter.
    </summary><param name='length'>The length of a CBOR array.
    </param><returns><c>true</c>
       if this filter allows CBOR arrays and an array's length is allowed under
      a filter; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="F:CBORTypeFilter.ByteString">

            <summary>A filter that allows byte strings.
    </summary>

</doc>
<doc name="M:CBORTypeFilter.GetSubFilter(System.Int32)">

            <summary>Gets the type filter for this array filter by its index.
    </summary><param name='index'>A zero-based index of the filter to retrieve.
    </param><returns>Returns None if the index is out of range, or Any if this filter doesn't
      filter an array. Returns the appropriate filter for the array index
      otherwise.
    </returns>

</doc>
<doc name="M:CBORTypeFilter.GetSubFilter(System.Int64)">

            <summary>Gets the type filter for this array filter by its index.
    </summary><param name='index'>A zero-based index of the filter to retrieve.
    </param><returns>Returns None if the index is out of range, or Any if this filter doesn't
      filter an array. Returns the appropriate filter for the array index
      otherwise.
    </returns>

</doc>
<doc name="M:CBORTypeFilter.MajorTypeMatches(System.Int32)">

            <summary>Returns whether the given CBOR major type matches a major type allowed by
      this filter.
    </summary><param name='type'>A CBOR major type from 0 to 7.
    </param><returns><c>true</c>
       if the given CBOR major type matches a major type allowed by this filter; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="F:CBORTypeFilter.NegativeInteger">

            <summary>A filter that allows negative integers.
    </summary>

</doc>
<doc name="M:CBORTypeFilter.NonFPSimpleValueAllowed">

            <summary>Returns whether this filter allows simple values that are not
      floating-point numbers.
    </summary><returns><c>true</c>
       if this filter allows simple values that are not floating-point numbers; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="F:CBORTypeFilter.None">

            <summary>A filter that allows no CBOR types.
    </summary>

</doc>
<doc name="M:CBORTypeFilter.TagAllowed(PeterO.Numbers.EInteger)">

            <summary>Gets a value indicating whether CBOR objects can have the given tag
      number.
    </summary><param name='bigTag'>A tag number. Returns false if this is less than 0.
    </param><returns><c>true</c>
       if CBOR objects can have the given tag number; otherwise, <c>false</c>
       .
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bigTag'/>
       is null.
    </exception>

</doc>
<doc name="M:CBORTypeFilter.TagAllowed(System.Int32)">

            <summary>Gets a value indicating whether CBOR objects can have the given tag
      number.
    </summary><param name='tag'>A tag number. Returns false if this is less than 0.
    </param><returns><c>true</c>
       if CBOR objects can have the given tag number; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:CBORTypeFilter.TagAllowed(System.Int64)">

            <summary>Gets a value indicating whether CBOR objects can have the given tag
      number.
    </summary><param name='longTag'>A tag number. Returns false if this is less than 0.
    </param><returns><c>true</c>
       if CBOR objects can have the given tag number; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="F:CBORTypeFilter.TextString">

            <summary>A filter that allows text strings.
    </summary>

</doc>
<doc name="F:CBORTypeFilter.UnsignedInteger">

            <summary>A filter that allows unsigned integers.
    </summary>

</doc>
<doc name="M:CBORTypeFilter.WithArrayAnyLength">

            <summary>Copies this filter and includes arrays of any length in the new filter.
    </summary><returns>A CBORTypeFilter object.
    </returns>

</doc>
<doc name="M:CBORTypeFilter.WithArrayExactLength(System.Int32,CBORTypeFilter[])">

            <summary>Copies this filter and includes CBOR arrays with an exact length to the
      new filter.
    </summary><param name='arrayLength'>The desired maximum length of an array.
    </param><param name='elements'>An array containing the allowed types for each element in the array.
      There must be at least as many elements here as given in the arrayLength
      parameter.
    </param><returns>A CBORTypeFilter object.
    </returns><exception cref='T:System.ArgumentException'>The parameter arrayLength is less than 0.
    </exception><exception cref='T:System.ArgumentNullException'>The parameter elements is null.
    </exception><exception cref='T:System.ArgumentException'>The parameter elements has fewer elements than specified in arrayLength.
    </exception>

</doc>
<doc name="M:CBORTypeFilter.WithArrayMinLength(System.Int32,CBORTypeFilter[])">

            <summary>Copies this filter and includes CBOR arrays with at least a given length
      to the new filter.
    </summary><param name='arrayLength'>The desired minimum length of an array.
    </param><param name='elements'>An array containing the allowed types for each element in the array.
      There must be at least as many elements here as given in the arrayLength
      parameter.
    </param><returns>A CBORTypeFilter object.
    </returns><exception cref='T:System.ArgumentException'>The parameter arrayLength is less than 0.
    </exception><exception cref='T:System.ArgumentNullException'>The parameter elements is null.
    </exception><exception cref='T:System.ArgumentException'>The parameter elements has fewer elements than specified in arrayLength.
    </exception>

</doc>
<doc name="M:CBORTypeFilter.WithByteString">

            <summary>Copies this filter and includes byte strings in the new filter.
    </summary><returns>A CBORTypeFilter object.
    </returns>

</doc>
<doc name="M:CBORTypeFilter.WithFloatingPoint">

            <summary>Copies this filter and includes floating-point numbers in the new filter.

    </summary><returns>A CBORTypeFilter object.
    </returns>

</doc>
<doc name="M:CBORTypeFilter.WithMap">

            <summary>Copies this filter and includes maps in the new filter.
    </summary><returns>A CBORTypeFilter object.
    </returns>

</doc>
<doc name="M:CBORTypeFilter.WithNegativeInteger">

            <summary>Copies this filter and includes negative integers in the new filter.
    </summary><returns>A CBORTypeFilter object.
    </returns>

</doc>
<doc name="M:CBORTypeFilter.WithTags(System.Int32[])">

            <summary>Copies this filter and includes a set of valid CBOR tags in the new
      filter.
    </summary><param name='tags'>An array of the CBOR tags to add to the new filter.
    </param><returns>A CBORTypeFilter object.
    </returns>

</doc>
<doc name="M:CBORTypeFilter.WithTextString">

            <summary>Copies this filter and includes text strings in the new filter.
    </summary><returns>A CBORTypeFilter object.
    </returns>

</doc>
<doc name="M:CBORTypeFilter.WithUnsignedInteger">

            <summary>Copies this filter and includes unsigned integers in the new filter.
    </summary><returns>A CBORTypeFilter object.
    </returns>

</doc>
<doc name="T:CBORTypeMapper">

            <summary>Holds converters to customize the serialization and
            deserialization behavior of <c>CBORObject.FromObject</c> and
            <c>CBORObject#ToObject</c>, as well as type filters for
            <c>ToObject</c></summary>

</doc>
<doc name="M:CBORTypeMapper.AddConverter``1(System.Type,ICBORConverter{``0})">

            <summary>Registers an object that converts objects of a given type
             to CBOR objects (called a CBOR converter).</summary><param name='type'>A Type object specifying the type that the
             converter converts to CBOR objects.</param><param name='converter'>The parameter <paramref name='converter'/>
             is an ICBORConverter object.</param>
<returns>This object.</returns>

<typeparam name='T'>Must be the same as the "type"
             parameter.</typeparam><exception cref='T:System.ArgumentNullException'>The parameter
             <paramref name='type'/> or <paramref name='converter'/> is
             null.</exception><exception cref='T:System.ArgumentException'>"Converter doesn't contain a
             proper ToCBORObject method".</exception>
</doc>
<doc name="M:CBORTypeMapper.AddTypeName(System.String)">

            <summary>Adds the fully qualified name of a Java or .NET type for use in type matching.</summary><param name='name'>The fully qualified name of a Java or .NET class (e.g., <c>java.math.BigInteger</c> or <c>System.Globalization.CultureInfo</c>).</param><returns>This object.</returns><exception cref='T:System.ArgumentNullException'>The parameter <paramref name='name'/> is null.</exception><exception cref='T:System.ArgumentException'>The parameter <paramref name='name'/> is empty.</exception>

</doc>
<doc name="M:CBORTypeMapper.AddTypePrefix(System.String)">

            <summary>Adds a prefix of a Java or .NET type for use in type matching.  A type matches a prefix if its fully qualified name is or begins with that prefix, using codepoint-by-codepoint (case-sensitive) matching.</summary><param name='prefix'>The prefix of a Java or .NET type (e.g., `java.math.` or `System.Globalization`).</param><returns>This object.</returns><exception cref='T:System.ArgumentNullException'>The parameter <paramref name='prefix'/> is null.</exception><exception cref='T:System.ArgumentException'>The parameter <paramref name='prefix'/> is empty.</exception>

</doc>
<doc name="P:CBORTypeMapper.ConverterInfo.Converter">
<summary>Gets an internal API value.</summary>
            <value>An internal API value.</value>
</doc>
<doc name="M:CBORTypeMapper.FilterTypeName(System.String)">

            <summary>Returns whether the given Java or .NET type name fits the filters given in this mapper.</summary><param name='typeName'>The fully qualified name of a Java or .NET class (e.g., <c>java.math.BigInteger</c> or <c>System.Globalization.CultureInfo</c>).</param><returns>Either <c>true</c> if the given Java or .NET type name fits the filters given in this mapper, or <c>false</c> otherwise.</returns>

</doc>
<doc name="T:CBORUtilities">

            <summary>Contains utility methods that may have use outside of the CBORObject
      class.
    </summary>

</doc>
<doc name="M:FastInteger2.Multiply(System.Int32)">

            <summary>Sets this object's value to the current value times another integer.
    </summary><param name='val'>The integer to multiply by.
    </param><returns>This instance.
    </returns>

</doc>
<doc name="P:FastInteger2.Sign">

            <summary>Gets the sign of this object's value.
    </summary><value>1 if positive, -1 if negative, 0 if zero.
    </value>

</doc>
<doc name="M:FastInteger2.Subtract(FastInteger2)">

            <summary>Sets this object's value to the current value minus the given FastInteger
      value.
    </summary><param name='val'>The subtrahend.
    </param><returns>This instance.
    </returns>

</doc>
<doc name="M:FastInteger2.SubtractInt(System.Int32)">

            <summary>Sets this object's value to the current value minus the given integer.
    </summary><param name='val'>The subtrahend.
    </param><returns>This instance.
    </returns>

</doc>
<doc name="T:ICBORConverter`1">

            <summary>Interface implemented by classes that convert objects of arbitrary types
      to CBOR objects.
    </summary><typeparam name='T'>
       Type to convert to a CBOR object.
    </typeparam>

</doc>
<doc name="M:ICBORConverter`1.ToCBORObject(`0)">

            <summary>Converts an object to a CBOR object.
    </summary><param name='obj'>An object to convert to a CBOR object.
    </param><returns>A CBOR object.
    </returns>

</doc>
<doc name="T:ICBORObjectConverter`1">
<summary>Interface implemented by classes that convert objects of arbitrary types
      to and from CBOR objects.
    </summary>
    <typeparam name='T'>
       Type of objects that a class implementing this method can convert to and
      from CBOR objects.
    </typeparam>
</doc>
<doc name="M:ICBORObjectConverter`1.FromCBORObject(CBORObject)">
<summary>Converts a CBOR object to an object of a type supported by the
      implementing class.
    </summary>
    <param name='cbor'>A CBOR object to convert.
    </param>
    <returns>The converted object.
    </returns>
    <exception cref='T:CBORException'>An error occurred in the conversion; for example, the conversion doesn't
      support the given CBOR object.
    </exception>
</doc>
<doc name="T:ICBORTag">

            <summary>Implemented by classes that validate CBOR objects belonging to a specific
      tag.
    </summary>

</doc>
<doc name="M:ICBORTag.GetTypeFilter">

            <summary>Gets a type filter specifying what kinds of CBOR objects are supported by
      this tag.
    </summary><returns>A CBOR type filter.
    </returns>

</doc>
<doc name="M:ICBORTag.ValidateObject(CBORObject)">

            <summary>Generates a CBOR object based on the data of another object. If the data
      is not valid, should throw a CBORException.
    </summary><param name='obj'>A CBOR object with the corresponding tag handled by the ICBORTag object.
    </param><returns>A CBORObject object. Note that this method may choose to return the same
      object as the parameter.
    </returns>

</doc>
<doc name="T:ICharacterInput">

            <summary>An interface for reading Unicode characters from a data source.
    </summary>

</doc>
<doc name="M:ICharacterInput.Read(System.Int32[],System.Int32,System.Int32)">

            <summary>Reads a sequence of Unicode code points from a data source.
    </summary><param name='chars'>Output buffer.
    </param><param name='index'>Index in the output buffer to start writing to.
    </param><param name='length'>Maximum number of code points to write.
    </param><returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff),
      or the value -1 indicating the end of the source.
    </returns>

</doc>
<doc name="M:ICharacterInput.ReadChar">

            <summary>Reads a Unicode character from a data source.
    </summary><returns>Either a Unicode code point (from 0-0xd7ff or from 0xe000 to 0x10ffff),
      or the value -1 indicating the end of the source.
    </returns>

</doc>
<doc name="T:JSONOptions">

            <seealso cref='M:CBORObject.ToJSONString'/><summary>Includes options to control how CBOR objects are converted
             to JSON.</summary>

</doc>
<doc name="M:JSONOptions.#ctor">

            <summary>Initializes a new instance of the <see cref='T:JSONOptions'/> class with default options.
    </summary>

</doc>
<doc name="M:JSONOptions.#ctor(System.Boolean)">

            <summary>Initializes a new instance of the <see cref='T:JSONOptions'/> class with the given values for the options.
    </summary><param name='base64Padding'>Whether padding is included when writing data in base64url or traditional
      base64 format to JSON.
    </param>

</doc>
<doc name="P:JSONOptions.Base64Padding">

            <summary>Gets a value indicating whether padding is written out when writing base64url or traditional base64 to JSON.</summary><value>The default is false, no padding.</value><remarks>The padding character is '='.</remarks>

</doc>
<doc name="F:JSONOptions.Default">

            <summary>The default options for converting CBOR objects to JSON.
    </summary>

</doc>
<doc name="T:PODOptions">

            <summary>Options for converting "plain old data" objects to CBOR objects.
    </summary>

</doc>
<doc name="M:PODOptions.#ctor">

            <summary>Initializes a new instance of the <see cref='T:PODOptions'/> class.
    </summary>

</doc>
<doc name="M:PODOptions.#ctor(System.Boolean,System.Boolean)">

            <summary>Initializes a new instance of the <see cref='T:PODOptions'/> class.
    </summary><param name='removeIsPrefix'>If set to
      <c>true</c>
       remove is prefix. NOTE: May be ignored in future versions of this library.
    </param><param name='useCamelCase'>If set to
      <c>true</c>
       use camel case.
    </param>

</doc>
<doc name="F:PODOptions.Default">

            <summary>The default settings for "plain old data" options.
    </summary>

</doc>
<doc name="P:PODOptions.RemoveIsPrefix">

            <summary>Gets a value indicating whether the "Is" prefix in
            property names is removed before they are used as keys.</summary><value><c>true</c> If the prefix is removed; otherwise, .
            <c>false</c>.</value>

</doc>
<doc name="P:PODOptions.UseCamelCase">

            <summary>Gets a value indicating whether property names are
            converted to camel case before they are used as keys.</summary><value><c>true</c> If the names are converted to camel case;
            otherwise, . <c>false</c>.</value>

</doc>
<doc name="T:StringRefs">

            <summary>Implements CBOR string references, described at
      <c>http://cbor.schmorp.de/stringref</c>
    </summary>

</doc>
<doc name="T:URIUtility">

            <summary>Contains utility methods for processing Uniform Resource Identifiers
      (URIs) and Internationalized Resource Identifiers (IRIs) under RFC3986 and
      RFC3987, respectively. In the following documentation, URIs and IRIs
      include URI references and IRI references, for convenience.
<para>There are five components to a URI: scheme, authority, path, query, and fragment identifier.
The generic syntax to these components is defined in RFC3986 and extended in RFC3987.  According to RFC3986, different URI schemes can further restrict the syntax of the authority, path, and query component (see also RFC 7320).  However, the syntax of fragment identifiers depends on the media type (also known as MIME type) of the resource a URI references (see also RFC 3986 and RFC 7320).  As of Aug. 24, 2018, only the following media types specify a syntax for fragment identifiers:</para>
<list>
<item>The following application/* media types: epub+zip, pdf, senml+cbor, senml+json, senml-exi, sensml+cbor, sensml+json, sensml-exi, smil,
vnd.3gpp-v2x-local-service-information, vnd.3gpp.mcdata-signalling,
vnd.collection.doc+json, vnd.hc+json, vnd.hyper+json,
vnd.hyper-item+json, vnd.mason+json,
vnd.microsoft.portable-executable, vnd.oma.bcast.sgdu,
vnd.shootproof+json</item>
<item>The following image/* media types: avci, avcs, heic, heic-sequence, heif, heif-sequence</item>
<item>The XML media types: application/xml, application/xml-external-parsed-entity, text/xml, text/xml-external-parsed-entity, application/xml-dtd</item>
<item>All media types with subtypes ending in "+xml" (see RFC 7303) use XPointer Framework syntax as fragment identifiers, except the following application/* media types: dicom+xml, senml+xml, sensml+xml, ttml+xml, xliff+xml, yang-data+xml</item>
<item>font/collection</item>
<item>multipart/x-mixed-replace</item>
<item>text/plain</item>
<item>text/csv</item>
<item>text/html</item>
<item>text/markdown</item>
<item>text/vnd.a</item></list>
     </summary>

</doc>
<doc name="M:URIUtility.EncodeStringForURI(System.String)">
<summary>Encodes characters other than "unreserved" characters for URIs.
    </summary>
    <param name='s'>A string to encode.
    </param>
    <returns>The encoded string.
    </returns>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
</doc>
<doc name="T:URIUtility.ParseMode">

            <summary>Specifies whether certain characters are allowed when parsing IRIs and
      URIs.
    </summary>

</doc>
<doc name="F:URIUtility.ParseMode.IRILenient">

            <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Even with this mode, strings with unpaired surrogate code points are
      considered invalid.
    </summary>

</doc>
<doc name="F:URIUtility.ParseMode.IRIStrict">

            <summary>The rules follow the syntax for parsing IRIs. In particular, many code
      points outside the Basic Latin range (U+0000 to U+007F) are allowed.
      Strings with unpaired surrogate code points are considered invalid.
    </summary>

</doc>
<doc name="F:URIUtility.ParseMode.IRISurrogateLenient">

            <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Unpaired surrogate code points are treated as though they were replacement
      characters instead for the purposes of these rules, so that strings with
      those code points are not considered invalid strings.
    </summary>

</doc>
<doc name="F:URIUtility.ParseMode.URILenient">

            <summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Code points outside the Basic Latin range (U+0000 to U+007F) are not
      allowed.
    </summary>

</doc>
<doc name="F:URIUtility.ParseMode.URIStrict">

            <summary>The rules follow the syntax for parsing IRIs, except that code points
      outside the Basic Latin range (U+0000 to U+007F) are not allowed.
    </summary>

</doc>
<doc name="M:URIUtility.PercentDecode(System.String)">
<summary>Decodes percent-encoding (of the form "%XX" where X is a hexadecimal
      digit) in the given string. Successive percent-encoded bytes are assumed
      to form characters in UTF-8.
    </summary>
    <param name='str'>A string that may contain percent encoding. May be null.
    </param>
    <returns>The string in which percent-encoding was decoded.
    </returns>
</doc>
<doc name="M:URIUtility.PercentDecode(System.String,System.Int32,System.Int32)">
<summary>Decodes percent-encoding (of the form "%XX" where X is a hexadecimal
      digit) in the given portion of a string. Successive percent-encoded bytes
      are assumed to form characters in UTF-8.
    </summary>
    <param name='str'>A string a portion of which may contain percent encoding. May be null.
    </param>
    <param name='index'>Zero-based index showing where the desired portion of
      <paramref name='str'/>
       begins.
    </param>
    <param name='endIndex'>Zero-based index showing where the desired portion of
      <paramref name='str'/>
       ends. The character before this index is the last character.
    </param>
    <returns>The portion of the given string in which percent-encoding was decoded.
      Returns null if
      <paramref name='str'/>
       is ull.
    </returns>
</doc>
<doc name="M:URIUtility.escapeURI(System.String,System.Int32)">

            <summary>Escapes characters that can't appear in URIs or IRIs. The function is
      idempotent; that is, calling the function again on the result with the
      same mode doesn't change the result.
    </summary><param name='s'>A string to escape.
    </param><param name='mode'>The parameter
      <paramref name='mode'/>
       is a 32-bit signed integer.
    </param><returns>A string possibly containing escaped characters, or null if s is null.
    </returns>

</doc>
<doc name="M:URIUtility.hasScheme(System.String)">

            <summary>Determines whether the string is a valid IRI with a scheme component.
      This can be used to check for relative IRI references.
      <para>The following cases return true:
      </para>
      <code>xx-x:mm example:/ww
      </code>
       The following cases return false:
      <code>x@y:/z /x/y/z example.xyz
      </code>
    </summary><param name='refValue'>A string representing an IRI to check.
    </param><returns><c>true</c>
       if the string is a valid IRI with a scheme component; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:URIUtility.hasSchemeForURI(System.String)">

            <summary>Determines whether the string is a valid URI with a scheme component.
      This can be used to check for relative URI references. The following cases
      return true:
      <code>http://example/z xx-x:mm example:/ww
      </code>
       The following cases return false:
      <code>x@y:/z /x/y/z example.xyz
      </code>
    </summary><param name='refValue'>A string representing an IRI to check.
    </param><returns><c>true</c>
       if the string is a valid URI with a scheme component; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:URIUtility.isValidCurieReference(System.String,System.Int32,System.Int32)">

            <summary>Determines whether the substring is a valid CURIE
             reference under RDFA 1.1. (The CURIE reference is the part after
             the colon.).</summary><param name='s'>A string containing a CURIE reference. Can be
             null.</param><param name='offset'>A zero-based index showing where the desired
             portion of "s" begins.</param><param name='length'>The number of elements in the desired portion
             of "s" (but not more than "s" 's length).</param><returns><c>true</c> if the substring is a valid CURIE reference
             under RDFA 1; otherwise, <c>false</c>. Returns false if <paramref name='s'/> is null.</returns><exception cref='T:System.ArgumentException'>Either <paramref name='offset'/> or <paramref name='length'/> is less than 0 or
             greater than <paramref name='s'/> 's length, or <paramref name='s'/> ' s length minus <paramref name='offset'/> is less than
             <paramref name='length'/>.</exception><exception cref='T:System.ArgumentNullException'>The parameter <paramref name='s'/> is null.</exception>

</doc>
<doc name="M:URIUtility.relativeResolve(System.String,System.String)">

            <summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary><param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c>
       .
    </param><param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c>
       .
    </param><returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue. Example:
      <c>http://example.com/my/path/dir/file.txt</c>
       .
    </returns>

</doc>
<doc name="M:URIUtility.relativeResolve(System.String,System.String,URIUtility.ParseMode)">

            <summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary><param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c>
       . Can be null.
    </param><param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c>
       .
    </param><param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param><returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If
      <paramref name='baseURI'/>
       is null or is not a valid IRI, returns refValue.
    </returns>

</doc>
<doc name="M:URIUtility.splitIRI(System.String)">

            <summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI reference is syntactically valid, splits the string
      into its components and returns an array containing the indices into the
      components.
    </summary><param name='s'>A string that contains an IRI. Can be null.
    </param><returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment identifier, respectively. The
      scheme, authority, query, and fragment identifier, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>

</doc>
<doc name="M:URIUtility.splitIRI(System.String,URIUtility.ParseMode)">

            <summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI is syntactically valid, splits the string into its
      components and returns an array containing the indices into the
      components.
    </summary><param name='s'>A string representing an IRI. Can be null.
    </param><param name='parseMode'>The parameter
      <paramref name='parseMode'/>
       is a ParseMode object.
    </param><returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment identifier, respectively. The
      scheme, authority, query, and fragment identifier, if present, will each
      be given without the ending colon, the starting "//", the starting "?",
      and the starting "#", respectively. If a component is absent, both indices
      in that pair will be -1. If the string is null or is not a valid IRI,
      returns null.
    </returns>

</doc>
<doc name="M:URIUtility.splitIRI(System.String,System.Int32,System.Int32,URIUtility.ParseMode)">

            <summary>Parses a substring that represents an Internationalized
            Resource Identifier (IRI) under RFC3987. If the IRI is
            syntactically valid, splits the string into its components and
            returns an array containing the indices into the
            components.</summary><param name='s'>A string that contains an IRI. Can be null.</param><param name='offset'>A zero-based index showing where the desired
            portion of "s" begins.</param><param name='length'>The length of the desired portion of "s" (but
            not more than "s" 's length).</param><param name='parseMode'>Parse mode that specifies whether certain
            characters are allowed when parsing IRIs and URIs.</param><returns>If the string is a valid IRI, returns an array of 10
            integers. Each of the five pairs corresponds to the start and end
            index of the IRI's scheme, authority, path, query, or fragment
            component, respectively. The scheme, authority, query, and fragment
            components, if present, will each be given without the ending
            colon, the starting "//", the starting "?", and the starting "#",
            respectively. If a component is absent, both indices in that pair
            will be -1 (an index won't be less than 0 in any other case). If
            the string is null or is not a valid IRI, returns null.</returns><exception cref='T:System.ArgumentException'>Either <paramref name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='s'/> 's length, or <paramref name='s'/> ' s length minus <paramref name='offset'/> is less than
            <paramref name='length'/>.</exception><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='s'/> is null.</exception>

</doc>
<doc name="T:PeterO.DataUtilities">

            <summary>Contains methods useful for reading and writing strings. It is designed
      to have no dependencies other than the basic runtime class library.
      <para>Many of these methods work with text encoded in UTF-8, an encoding form
        of the Unicode Standard which uses one byte to encode the most basic
        characters and two to four bytes to encode other characters. For
        example, the
        <c>GetUtf8</c>
         method converts a text string to an array of bytes in UTF-8.
      </para>
      <para>In C# and Java, text strings are represented as sequences of 16-bit
        values called
        <c>char</c>
         s. These sequences are well-formed under UTF-16, a 16-bit encoding form
        of Unicode, except if they contain unpaired surrogate code points. (A
        surrogate code point is used to encode supplementary characters, those
        with code points U+10000 or higher, in UTF-16. A surrogate pair is a
        high surrogate [U+D800 to U+DBFF] followed by a low surrogate [U+DC00 to
        U+DFFF]. An unpaired surrogate code point is a surrogate not appearing
        in a surrogate pair.) Many of the methods in this class allow setting
        the behavior to follow when unpaired surrogate code points are found in
        text strings, such as throwing an error or treating the unpaired
        surrogate as a replacement character (U+FFFD).
      </para>
    </summary>

</doc>
<doc name="M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32)">

            <summary>Gets the Unicode code point at the given index of the string.
    </summary><param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param><param name='index'>Index of the current position into the string.
    </param><returns>The Unicode code point at the given position. Returns -1 if
      <paramref name='index'/>
       is less than 0, or is the string's length or greater. Returns the
      replacement character (U+FFFD) if the current character is an unpaired
      surrogate code point.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.DataUtilities.CodePointAt(System.String,System.Int32,System.Int32)">

            <summary>Gets the Unicode code point at the given index of the string.
    </summary><param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param><param name='index'>Index of the current position into the string.
    </param><param name='surrogateBehavior'>Specifies what kind of value to return if the previous character is an
      unpaired surrogate code point: if 0, return the replacement character
      (U+FFFD); if 1, return the value of the surrogate code point; if neither 0
      nor 1, return -1.
    </param><returns>The Unicode code point at the current position. Returns -1 if
      <paramref name='index'/>
       is less than 0, or is the string's length or greater. Returns a value as
      specified under
      <paramref name='surrogateBehavior'/>
       if the previous character is an unpaired surrogate code point.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32)">

            <summary>Gets the Unicode code point just before the given index of the string.
    </summary><param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param><param name='index'>Index of the current position into the string.
    </param><returns>The Unicode code point at the previous position. Returns -1 if
      <paramref name='index'/>
       is 0 or less, or is greater than the string's length. Returns the
      replacement character (U+FFFD) if the previous character is an unpaired
      surrogate code point.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.DataUtilities.CodePointBefore(System.String,System.Int32,System.Int32)">

            <summary>Gets the Unicode code point just before the given index of the string.
    </summary><param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param><param name='index'>Index of the current position into the string.
    </param><param name='surrogateBehavior'>Specifies what kind of value to return if the previous character is an
      unpaired surrogate code point: if 0, return the replacement character
      (U+FFFD); if 1, return the value of the surrogate code point; if neither 0
      nor 1, return -1.
    </param><returns>The Unicode code point at the previous position. Returns -1 if
      <paramref name='index'/>
       is 0 or less, or is greater than the string's length. Returns a value as
      specified under
      <paramref name='surrogateBehavior'/>
       if the previous character is an unpaired surrogate code point.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.DataUtilities.CodePointCompare(System.String,System.String)">

            <summary>Compares two strings in Unicode code point order. Unpaired surrogate code
      points are treated as individual code points.
    </summary><param name='strA'>The first string. Can be null.
    </param><param name='strB'>The second string. Can be null.
    </param><returns>A value indicating which string is " less" or " greater" . 0: Both
      strings are equal or null. Less than 0: a is null and b isn't; or the
      first code point that's different is less in A than in B; or b starts with
      a and is longer than a. Greater than 0: b is null and a isn't; or the
      first code point that's different is greater in A than in B; or a starts
      with b and is longer than b.
    </returns>

</doc>
<doc name="M:PeterO.DataUtilities.CodePointLength(System.String)">

            <summary>Finds the number of Unicode code points in the given text
            string. Unpaired surrogate code points increase this number by 1.
            This is not necessarily the length of the string in "char"
            s.</summary><param name='str'>The parameter <paramref name='str'/> is a text string.</param><returns>The number of Unicode code points in the given
            string.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception>

</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean)">

            <summary><para>Encodes a string in UTF-8 as a byte array.  This method does not insert a byte-order mark (U+FEFF) at the beginning of the encoded byte array.</para>
<para>REMARK: It is not recommended to use <c>Encoding.UTF8.GetBytes</c> in .NET, or the <c>getBytes()</c> method in Java to do this.  For instance, <c>getBytes()</c> encodes text strings in an unspecified character encoding.  Both behaviors can be undesirable.</para>
    </summary><param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param><param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param><returns>The string encoded in UTF-8.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception><exception cref='T:System.ArgumentException'>The string contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false, or an internal error occurred.
    </exception>

</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8Bytes(System.String,System.Boolean,System.Boolean)">

            <summary><para>Encodes a string in UTF-8 as a byte array.  This method does not insert a byte-order mark (U+FEFF) at the beginning of the encoded byte array.</para>
<para>REMARK: It is not recommended to use <c>Encoding.UTF8.GetBytes</c> in .NET, or the <c>getBytes()</c> method in Java to do this.  For instance, <c>getBytes()</c> encodes text strings in an unspecified character encoding.  Both behaviors can be undesirable.</para>
    </summary><param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param><param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param><param name='lenientLineBreaks'>If true, replaces carriage return (CR) not followed by line feed (LF) and
      LF not preceded by CR with CR-LF pairs.
    </param><returns>The string encoded in UTF-8.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception><exception cref='T:System.ArgumentException'>The string contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false, or an internal error occurred.
    </exception>

</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8Length(System.String,System.Boolean)">

            <summary>Calculates the number of bytes needed to encode a string in UTF-8.
    </summary><param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param><param name='replace'>If true, treats unpaired surrogate code points as having 3 UTF-8 bytes
      (the UTF-8 length of the replacement character U+FFFD).
    </param><returns>The number of bytes needed to encode the given string in UTF-8, or -1 if
      the string contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Boolean)">

            <summary>Generates a text string from a UTF-8 byte array.
    </summary><param name='bytes'>A byte array containing text encoded in UTF-8.
    </param><param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when invalid UTF-8 is seen.
    </param><returns>A string represented by the UTF-8 byte array.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bytes'/>
       is null.
    </exception><exception cref='T:System.ArgumentException'>The string is not valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </exception>

</doc>
<doc name="M:PeterO.DataUtilities.GetUtf8String(System.Byte[],System.Int32,System.Int32,System.Boolean)">

            <summary>Generates a text string from a portion of a UTF-8 byte array.
    </summary><param name='bytes'>A byte array containing text encoded in UTF-8.
    </param><param name='offset'>Offset into the byte array to start reading.
    </param><param name='bytesCount'>Length, in bytes, of the UTF-8 text string.
    </param><param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when invalid UTF-8 is seen.
    </param><returns>A string represented by the UTF-8 byte array.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='bytes'/>
       is null.
    </exception><exception cref='T:System.ArgumentException'>The portion of the byte array is not valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </exception><exception cref='T:System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='bytesCount'/>
       is less than 0, or offset plus bytesCount is greater than the length of
      "data" .
    </exception>

</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8(System.IO.Stream,System.Int32,System.Text.StringBuilder,System.Boolean)">

            <summary>Reads a string in UTF-8 encoding from a data stream.
    </summary><param name='stream'>A readable data stream.
    </param><param name='bytesCount'>The length, in bytes, of the string. If this is less than 0, this
      function will read until the end of the stream.
    </param><param name='builder'>A string builder object where the resulting string will be stored.
    </param><param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when an unpaired surrogate code point
      is seen.
    </param><returns>0 if the entire string was read without errors, -1 if the string is not
      valid UTF-8 and
      <paramref name='replace'/>
       is false, or -2 if the end of the stream was reached before the last
      character was read completely (which is only the case if
      <paramref name='bytesCount'/>
       is 0 or greater).
    </returns><exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null or
      <paramref name='builder'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8FromBytes(System.Byte[],System.Int32,System.Int32,System.Text.StringBuilder,System.Boolean)">

            <summary>Reads a string in UTF-8 encoding from a byte array.
    </summary><param name='data'>A byte array containing a UTF-8 text string.
    </param><param name='offset'>Offset into the byte array to start reading.
    </param><param name='bytesCount'>Length, in bytes, of the UTF-8 text string.
    </param><param name='builder'>A string builder object where the resulting string will be stored.
    </param><param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, stops processing when invalid UTF-8 is seen.
    </param><returns>0 if the entire string was read without errors, or -1 if the string is
      not valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='data'/>
       is null or
      <paramref name='builder'/>
       is null.
    </exception><exception cref='T:System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='bytesCount'/>
       is less than 0, or offset plus bytesCount is greater than the length of
      <paramref name='data'/>
       .
    </exception>

</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream)">

            <summary>Reads a string in UTF-8 encoding from a data stream in full and returns
      that string. Replaces invalid encoding with the replacement character
      (U+FFFD).
    </summary><param name='stream'>A readable data stream.
    </param><returns>The string read.
    </returns><exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.DataUtilities.ReadUtf8ToString(System.IO.Stream,System.Int32,System.Boolean)">

            <summary>Reads a string in UTF-8 encoding from a data stream and returns that
      string.
    </summary><param name='stream'>A readable data stream.
    </param><param name='bytesCount'>The length, in bytes, of the string. If this is less than 0, this
      function will read until the end of the stream.
    </param><param name='replace'>If true, replaces invalid encoding with the replacement character
      (U+FFFD). If false, throws an error if an unpaired surrogate code point is
      seen.
    </param><returns>The string read.
    </returns><exception cref='T:System.IO.IOException'>An I/O error occurred; or, the string is not valid UTF-8 and
      <paramref name='replace'/>
       is false.
    </exception><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='stream'/>
       is null.
    </exception>

</doc>
<doc name="M:PeterO.DataUtilities.ToLowerCaseAscii(System.String)">

            <summary>Returns a string with the basic upper-case letters A to Z (U+0041 to
      U+005A) converted to lower-case. Other characters remain unchanged.
    </summary><param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param><returns>The converted string, or null if
      <paramref name='str'/>
       is null.
    </returns>

</doc>
<doc name="M:PeterO.DataUtilities.ToUpperCaseAscii(System.String)">

            <summary>Returns a string with the basic lower-case letters A to Z (U+0061 to
      U+007A) converted to upper-case. Other characters remain unchanged.
    </summary><param name='str'>The parameter
      <paramref name='str'/>
       is a text string.
    </param><returns>The converted string, or null if
      <paramref name='str'/>
       is null.
    </returns>

</doc>
<doc name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.IO.Stream,System.Boolean)">

            <summary>Writes a string in UTF-8 encoding to a data stream.
    </summary><param name='str'>A string to write.
    </param><param name='stream'>A writable data stream.
    </param><param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param><returns>0 if the entire string was written; or -1 if the string contains an
      unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null or
      <paramref name='stream'/>
       is null.
    </exception><exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>

</doc>
<doc name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean)">

            <summary>Writes a portion of a string in UTF-8 encoding to a data stream.
    </summary><param name='str'>A string to write.
    </param><param name='offset'>The zero-based index where the string portion to write begins.
    </param><param name='length'>The length of the string portion to write.
    </param><param name='stream'>A writable data stream.
    </param><param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param><returns>0 if the entire string portion was written; or -1 if the string portion
      contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null or
      <paramref name='stream'/>
       is null.
    </exception><exception cref='T:System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='length'/>
       is less than 0, or
      <paramref name='offset'/>
       plus
      <paramref name='length'/>
       is greater than the string's length.
    </exception><exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>

</doc>
<doc name="M:PeterO.DataUtilities.WriteUtf8(System.String,System.Int32,System.Int32,System.IO.Stream,System.Boolean,System.Boolean)">

            <summary>Writes a portion of a string in UTF-8 encoding to a data stream.
    </summary><param name='str'>A string to write.
    </param><param name='offset'>The zero-based index where the string portion to write begins.
    </param><param name='length'>The length of the string portion to write.
    </param><param name='stream'>A writable data stream.
    </param><param name='replace'>If true, replaces unpaired surrogate code points with the replacement
      character (U+FFFD). If false, stops processing when an unpaired surrogate
      code point is seen.
    </param><param name='lenientLineBreaks'>If true, replaces carriage return (CR) not followed by line feed (LF) and
      LF not preceded by CR with CR-LF pairs.
    </param><returns>0 if the entire string portion was written; or -1 if the string portion
      contains an unpaired surrogate code point and
      <paramref name='replace'/>
       is false.
    </returns><exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='str'/>
       is null or
      <paramref name='stream'/>
       is null.
    </exception><exception cref='T:System.ArgumentException'>The parameter
      <paramref name='offset'/>
       is less than 0,
      <paramref name='length'/>
       is less than 0, or
      <paramref name='offset'/>
       plus
      <paramref name='length'/>
       is greater than the string's length.
    </exception><exception cref='T:System.IO.IOException'>An I/O error occurred.
    </exception>

</doc>
<doc name="T:PeterO.ExtendedDecimal">

            <summary><para><b>This class is largely obsolete. It will be replaced by a new version
          of this class in a different namespace/package and library, called
          <c>PeterO.Numbers.EDecimal</c>
           in the
          <a href='https://www.nuget.org/packages/PeterO.Numbers'>
            <c>PeterO.Numbers</c>
          </a>
           library (in .NET), or
          <c>com.upokecenter.numbers.EDecimal</c>
           in the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c>
          </a>
           artifact (in Java). This new class can be used in the
          <c>CBORObject.FromObject(object)</c>
           method (by including the new library in your code, among other
          things).</b>
      </para>
       Represents an arbitrary-precision decimal floating-point number.
      <para><b>About decimal arithmetic</b>
      </para>
      <para>Decimal (base-10) arithmetic, such as that provided by this class, is
        appropriate for calculations involving such real-world data as prices
        and other sums of money, tax rates, and measurements. These calculations
        often involve multiplying or dividing one decimal with another decimal,
        or performing other operations on decimal numbers. Many of these
        calculations also rely on rounding behavior in which the result after
        rounding is a decimal number (for example, multiplying a price by a
        premium rate, then rounding, should result in a decimal amount of
        money).
      </para>
      <para>On the other hand, most implementations of
        <c>float</c>
         and
        <c>double</c>
         , including in C# and Java, store numbers in a binary (base-2)
        floating-point format and use binary floating-point arithmetic. Many
        decimal numbers can't be represented exactly in binary floating-point
        format (regardless of its length). Applying binary arithmetic to numbers
        intended to be decimals can sometimes lead to unintuitive results, as is
        shown in the description for the FromDouble() method of this class.
      </para>
      <para><b>About ExtendedDecimal instances</b>
      </para>
      <para>Each instance of this class consists of an integer mantissa and an
        integer exponent, both arbitrary-precision. The value of the number
        equals mantissa * 10^exponent.
      </para>
      <para>The mantissa is the value of the digits that make up a number, ignoring
        the decimal point and exponent. For example, in the number 2356.78, the
        mantissa is 235678. The exponent is where the "floating" decimal point
        of the number is located. A positive exponent means "move it to the
        right", and a negative exponent means "move it to the left." In the
        example 2, 356.78, the exponent is -2, since it has 2 decimal places and
        the decimal point is "moved to the left by 2." Therefore, in the
        arbitrary-precision decimal representation, this number would be stored
        as 235678 * 10^-2.
      </para>
      <para>The mantissa and exponent format preserves trailing zeros in the
        number's value. This may give rise to multiple ways to store the same
        value. For example, 1.00 and 1 would be stored differently, even though
        they have the same value. In the first case, 100 * 10^-2 (100 with
        decimal point moved left by 2), and in the second case, 1 * 10^0 (1 with
        decimal point moved 0).
      </para>
      <para>This class also supports values for negative zero, not-a-number (NaN)
        values, and infinity.
        <b>Negative zero</b>
         is generally used when a negative number is rounded to 0; it has the
        same mathematical value as positive zero.
        <b>Infinity</b>
         is generally used when a non-zero number is divided by zero, or when a
        very high number can't be represented in a given exponent range.
        <b>Not-a-number</b>
         is generally used to signal errors.
      </para>
      <para><b>Errors and Exceptions</b>
      </para>
      <para>Passing a signaling NaN to any arithmetic operation shown here will
        signal the flag FlagInvalid and return a quiet NaN, even if another
        operand to that operation is a quiet NaN, unless noted otherwise.
      </para>
      <para>Passing a quiet NaN to any arithmetic operation shown here will return
        a quiet NaN, unless noted otherwise. Invalid operations will also return
        a quiet NaN, as stated in the individual methods.
      </para>
      <para>Unless noted otherwise,passing a null arbitrary-precision decimal
        argument to any method here will throw an exception.
      </para>
      <para>When an arithmetic operation signals the flag FlagInvalid,
        FlagOverflow, or FlagDivideByZero, it will not throw an exception too,
        unless the flag's trap is enabled in the precision context (see
        EContext's Traps property).
      </para>
      <para>If an operation requires creating an intermediate value that might be
        too big to fit in memory (or might require more than 2 gigabytes of
        memory to store -- due to the current use of a 32-bit integer internally
        as a length), the operation may signal an invalid-operation flag and
        return not-a-number (NaN). In certain rare cases, the CompareTo method
        may throw OutOfMemoryException (called OutOfMemoryError in Java) in the
        same circumstances.
      </para>
      <para><b>Serialization</b>
      </para>
      <para>An arbitrary-precision decimal value can be serialized (converted to a
        stable format) in one of the following ways:
      </para>
      <list>
        <item>By calling the toString() method, which will always return distinct
          strings for distinct arbitrary-precision decimal values.
        </item>
        <item>By calling the UnsignedMantissa, Exponent, and IsNegative properties,
          and calling the IsInfinity, IsQuietNaN, and IsSignalingNaN methods.
          The return values combined will uniquely identify a particular
          arbitrary-precision decimal value.
        </item>
      </list>
      <para><b>Thread safety</b>
      </para>
      <para>Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        properties are interchangeable, so they should not be compared using the
        "==" operator (which might only check if each side of the operator is
        the same instance).
      </para>
      <para><b>Comparison considerations</b>
      </para>
      <para>This class's natural ordering (under the CompareTo method) is not
        consistent with the Equals method. This means that two values that
        compare as equal under the CompareTo method might not be equal under the
        Equals method. The CompareTo method compares the mathematical values of
        the two instances passed to it (and considers two different NaN values
        as equal), while two instances with the same mathematical value, but
        different exponents, will be considered unequal under the Equals method.

      </para>
    </summary>

</doc>
<doc name="M:PeterO.ExtendedDecimal.CompareTo(PeterO.ExtendedDecimal)">

            <summary>Compares this extended decimal to another.
    </summary><param name='other'>The parameter
      <paramref name='other'/>
       is an ExtendedDecimal object.
    </param><returns>Less than 0 if this value is less than, 0 if equal to, or greater than 0
      if greater than the other extended decimal.
    </returns>

</doc>
<doc name="M:PeterO.ExtendedDecimal.Create(PeterO.BigInteger,PeterO.BigInteger)">

            <summary>Creates a number with the value
            exponent*10^mantissa.</summary><param name='mantissa'>The un-scaled value.</param><param name='exponent'>The decimal exponent.</param><returns>An arbitrary-precision decimal number.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='mantissa'/> or <paramref name='exponent'/> is
            null.</exception>

</doc>
<doc name="M:PeterO.ExtendedDecimal.Equals(PeterO.ExtendedDecimal)">

            <summary>Determines whether this object's mantissa and exponent are equal to those
      of another object.
    </summary><param name='other'>An arbitrary-precision decimal number.
    </param><returns><c>true</c>
       if this object's mantissa and exponent are equal to those of another
      object; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.ExtendedDecimal.Equals(System.Object)">

            <summary>Determines whether this object's mantissa and exponent are equal to those
      of another object and that other object is an arbitrary-precision decimal
      number.
    </summary><param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param><returns><c>true</c>
       if the objects are equal; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="P:PeterO.ExtendedDecimal.Exponent">

            <summary>Gets this object's exponent. This object's value will be
            an integer if the exponent is positive or zero.</summary><value>This object's exponent. This object's value will be an
            integer if the exponent is positive or zero.</value>

</doc>
<doc name="M:PeterO.ExtendedDecimal.FromString(System.String)">

            <summary>Creates a decimal number from a text string that
            represents a number. See <c>FromString(String, int, int,
            EContext)</c> for more information.</summary><param name='str'>A string that represents a number.</param><returns>An arbitrary-precision decimal number with the same value
            as the given string.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception><exception cref='T:System.FormatException'>The parameter <paramref name='str'/> is not a correctly formatted number
            string.</exception>

</doc>
<doc name="M:PeterO.ExtendedDecimal.GetHashCode">

            <summary>Calculates this object's hash code. No application or process IDs are
      used in the hash code calculation.
    </summary><returns>This object's hash code.
    </returns>

</doc>
<doc name="M:PeterO.ExtendedDecimal.IsInfinity">

            <summary>Gets a value indicating whether this object is positive or negative
      infinity.
    </summary><returns><c>true</c>
       if this object is positive or negative infinity; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.ExtendedDecimal.IsNaN">

            <summary>Gets a value indicating whether this object is not a number (NaN).
    </summary><returns><c>true</c>
       if this object is not a number (NaN); otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="P:PeterO.ExtendedDecimal.IsNegative">

            <summary>Gets a value indicating whether this object is negative,
            including negative zero.</summary><value><c>true</c> If this object is negative, including negative
            zero; otherwise, . <c>false</c>.</value>

</doc>
<doc name="M:PeterO.ExtendedDecimal.IsQuietNaN">

            <summary>Gets a value indicating whether this object is a quiet not-a-number
      value.
    </summary><returns><c>true</c>
       if this object is a quiet not-a-number value; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="P:PeterO.ExtendedDecimal.Mantissa">

            <summary>Gets this object's un-scaled value.</summary><value>This object's un-scaled value. Will be negative if this
            object's value is negative (including a negative NaN).</value>

</doc>
<doc name="F:PeterO.ExtendedDecimal.NaN">

            <summary>A not-a-number value.
    </summary>

</doc>
<doc name="F:PeterO.ExtendedDecimal.NegativeInfinity">

            <summary>Negative infinity, less than any other number.
    </summary>

</doc>
<doc name="F:PeterO.ExtendedDecimal.NegativeZero">

            <summary>Represents the number negative zero.
    </summary>

</doc>
<doc name="F:PeterO.ExtendedDecimal.One">

            <summary>Represents the number 1.
    </summary>

</doc>
<doc name="F:PeterO.ExtendedDecimal.PositiveInfinity">

            <summary>Positive infinity, greater than any other number.
    </summary>

</doc>
<doc name="P:PeterO.ExtendedDecimal.Sign">

            <summary>Gets this value's sign: -1 if negative; 1 if positive; 0
            if zero.</summary><value>This value's sign: -1 if negative; 1 if positive; 0 if
            zero.</value>

</doc>
<doc name="F:PeterO.ExtendedDecimal.SignalingNaN">

            <summary>A not-a-number value that signals an invalid operation flag when it's
      passed as an argument to any arithmetic operation in arbitrary-precision
      decimal.
    </summary>

</doc>
<doc name="F:PeterO.ExtendedDecimal.Ten">

            <summary>Represents the number 10.
    </summary>

</doc>
<doc name="M:PeterO.ExtendedDecimal.ToDouble">

            <summary>Converts this value to a 64-bit floating-point number. The half-even
      rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 64-bit floating point
        number's mantissa for a quiet NaN, and clears it for a signaling NaN.
        Then the next highest bit of the mantissa is cleared for a quiet NaN,
        and set for a signaling NaN. Then the other bits of the mantissa are set
        to the lowest bits of this object's unsigned mantissa.
      </para>
    </summary><returns>The closest 64-bit floating-point number to this value. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 64-bit floating point number.
    </returns>

</doc>
<doc name="M:PeterO.ExtendedDecimal.ToSingle">

            <summary>Converts this value to a 32-bit floating-point number. The half-even
      rounding mode is used.
      <para>If this value is a NaN, sets the high bit of the 32-bit floating point
        number's mantissa for a quiet NaN, and clears it for a signaling NaN.
        Then the next highest bit of the mantissa is cleared for a quiet NaN,
        and set for a signaling NaN. Then the other bits of the mantissa are set
        to the lowest bits of this object's unsigned mantissa.
      </para>
    </summary><returns>The closest 32-bit floating-point number to this value. The return value
      can be positive infinity or negative infinity if this value exceeds the
      range of a 32-bit floating point number.
    </returns>

</doc>
<doc name="M:PeterO.ExtendedDecimal.ToString">

            <summary>Converts this value to a string. Returns a value compatible with this
      class's FromString method.
    </summary><returns>A string representation of this object.
    </returns>

</doc>
<doc name="P:PeterO.ExtendedDecimal.UnsignedMantissa">

            <summary>Gets the absolute value of this object's un-scaled
            value.</summary><value>The absolute value of this object's un-scaled value.</value>

</doc>
<doc name="F:PeterO.ExtendedDecimal.Zero">

            <summary>Represents the number 0.
    </summary>

</doc>
<doc name="T:PeterO.ExtendedFloat">

            <summary><para><b>This class is largely obsolete. It will be replaced by a new version
          of this class in a different namespace/package and library, called
          <c>PeterO.Numbers.EFloat</c>
           in the
          <a href='https://www.nuget.org/packages/PeterO.Numbers'>
            <c>PeterO.Numbers</c>
          </a>
           library (in .NET), or
          <c>com.upokecenter.numbers.EFloat</c>
           in the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c>
          </a>
           artifact (in Java). This new class can be used in the
          <c>CBORObject.FromObject(object)</c>
           method (by including the new library in your code, among other
          things).</b>
      </para>
      <para>Represents an arbitrary-precision binary floating-point number.
        Consists of an integer mantissa and an integer exponent, both
        arbitrary-precision. The value of the number equals mantissa *
        2^exponent. This class also supports values for negative zero,
        not-a-number (NaN) values, and infinity.
      </para>
      <para>Passing a signaling NaN to any arithmetic operation shown here will
        signal the flag FlagInvalid and return a quiet NaN, even if another
        operand to that operation is a quiet NaN, unless noted otherwise.
      </para>
      <para>Passing a quiet NaN to any arithmetic operation shown here will return
        a quiet NaN, unless noted otherwise.
      </para>
      <para>Unless noted otherwise,passing a null arbitrary-precision binary float
        argument to any method here will throw an exception.
      </para>
      <para>When an arithmetic operation signals the flag FlagInvalid,
        FlagOverflow, or FlagDivideByZero, it will not throw an exception too,
        unless the operation's trap is enabled in the precision context (see
        PrecisionContext's Traps property).
      </para>
      <para>An arbitrary-precision binary float value can be serialized in one of
        the following ways:
      </para>
      <list>
        <item>By calling the toString() method. However, not all strings can be
          converted back to an arbitrary-precision binary float without loss,
          especially if the string has a fractional part.
        </item>
        <item>By calling the UnsignedMantissa, Exponent, and IsNegative properties,
          and calling the IsInfinity, IsQuietNaN, and IsSignalingNaN methods.
          The return values combined will uniquely identify a particular
          arbitrary-precision binary float value.
        </item>
      </list>
      <para>If an operation requires creating an intermediate value that might be
        too big to fit in memory (or might require more than 2 gigabytes of
        memory to store -- due to the current use of a 32-bit integer internally
        as a length), the operation may signal an invalid-operation flag and
        return not-a-number (NaN). In certain rare cases, the CompareTo method
        may throw OutOfMemoryException (called OutOfMemoryError in Java) in the
        same circumstances.
      </para>
      <para><b>Thread safety:</b>
         Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        properties are interchangeable, so they should not be compared using the
        "==" operator (which might only check if each side of the operator is
        the same instance).
      </para>
    </summary>

</doc>
<doc name="M:PeterO.ExtendedFloat.CompareTo(PeterO.ExtendedFloat)">

            <summary>Compares this extended float to another.
    </summary><param name='other'>An extended float to compare this one with.
    </param><returns>Less than 0 if this value is less than, 0 if equal to, or greater than 0
      if greater than the other value.
    </returns>

</doc>
<doc name="M:PeterO.ExtendedFloat.Create(PeterO.BigInteger,PeterO.BigInteger)">

            <summary>Creates a number with the value
            exponent*2^mantissa.</summary><param name='mantissa'>The un-scaled value.</param><param name='exponent'>The binary exponent.</param><returns>An arbitrary-precision binary float.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='mantissa'/> or <paramref name='exponent'/> is
            null.</exception>

</doc>
<doc name="M:PeterO.ExtendedFloat.Create(System.Int32,System.Int32)">

            <summary>Creates a number with the value exponent*2^mantissa.
    </summary><param name='mantissaSmall'>The un-scaled value.
    </param><param name='exponentSmall'>The binary exponent.
    </param><returns>An arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.ExtendedFloat.Equals(PeterO.ExtendedFloat)">

            <summary>Determines whether this object's mantissa and exponent are
            equal to those of another object.</summary><param name='other'>An arbitrary-precision binary float.</param><returns><c>true</c> if this object's mantissa and exponent are
            equal to those of another object; otherwise, <c>false</c>
            .</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='other'/> is null.</exception>

</doc>
<doc name="M:PeterO.ExtendedFloat.Equals(System.Object)">

            <summary>Determines whether this object's mantissa and exponent are equal to those
      of another object and that other object is an arbitrary-precision decimal
      number.
    </summary><param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param><returns><c>true</c>
       if the objects are equal; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.ExtendedFloat.EqualsInternal(PeterO.ExtendedFloat)">

            <summary>Determines whether this object's mantissa and exponent are
            equal to those of another object.</summary><param name='otherValue'>An arbitrary-precision binary
            float.</param><returns><c>true</c> if this object's mantissa and exponent are
            equal to those of another object; otherwise, <c>false</c>
            .</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='otherValue'/> is null.</exception>

</doc>
<doc name="P:PeterO.ExtendedFloat.Exponent">

            <summary>Gets this object's exponent. This object's value will be
            an integer if the exponent is positive or zero.</summary><value>This object's exponent. This object's value will be an
            integer if the exponent is positive or zero.</value>

</doc>
<doc name="M:PeterO.ExtendedFloat.FromString(System.String)">

            <summary>Creates a binary float from a text string that represents a number.
    </summary><param name='str'>A text string containing the number to convert.
    </param><returns>The parsed number, converted to arbitrary-precision binary float.
    </returns>

</doc>
<doc name="M:PeterO.ExtendedFloat.FromString(System.String,System.Int32,System.Int32,PeterO.PrecisionContext)">

            <summary>Creates a binary float from a text string that represents
            a number. Note that if the string contains a negative exponent, the
            resulting value might not be exact, in which case the resulting
            binary float will be an approximation of this decimal number's
            value. (NOTE: This documentation previously said the binary float
            will contain enough precision to accurately convert it to a 32-bit
            or 64-bit floating point number. Due to double rounding, this will
            generally not be the case for certain numbers converted from
            decimal to ExtendedFloat via this method and in turn converted to
            <c>double</c> or <c>float</c>.)
            <para>The format of the string generally consists of:</para>
            <list type=''>
            <item>An optional plus sign ("+" , U+002B) or minus sign ("-",
            U+002D) (if '-' , the value is negative.)</item>
            <item>One or more digits, with a single optional decimal point
            after the first digit and before the last digit.</item>
            <item>Optionally, "E+"/"e+" (positive exponent) or "E-"/"e-"
            (negative exponent) plus one or more digits specifying the
            exponent.</item></list>
            <para>The string can also be "-INF", "-Infinity", "Infinity",
            "INF", quiet NaN ("NaN") followed by any number of digits, or
            signaling NaN ("sNaN") followed by any number of digits, all in any
            combination of upper and lower case.</para>
            <para>All characters mentioned above are the corresponding
            characters in the Basic Latin range. In particular, the digits must
            be the basic digits 0 to 9 (U+0030 to U+0039). The string is not
            allowed to contain white space characters, including
            spaces.</para></summary><param name='str'>The parameter <paramref name='str'/> is a text
            string.</param><param name='offset'>A zero-based index showing where the desired
            portion of <paramref name='str'/> begins.</param><param name='length'>The length, in code units, of the desired
            portion of <paramref name='str'/> (but not more than <paramref name='str'/> 's length).</param><param name='ctx'>A PrecisionContext object specifying the
            precision, rounding, and exponent range to apply to the parsed
            number. Can be null.</param><returns>The parsed number, converted to arbitrary-precision binary
            float.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='str'/> is null.</exception><exception cref='T:System.ArgumentException'>Either <paramref name='offset'/> or <paramref name='length'/> is less than 0 or
            greater than <paramref name='str'/> 's length, or <paramref name='str'/> ' s length minus <paramref name='offset'/> is less
            than <paramref name='length'/>.</exception>

</doc>
<doc name="M:PeterO.ExtendedFloat.GetHashCode">

            <summary>Calculates this object's hash code. No application or process IDs are
      used in the hash code calculation.
    </summary><returns>This object's hash code.
    </returns>

</doc>
<doc name="M:PeterO.ExtendedFloat.IsInfinity">

            <summary>Gets a value indicating whether this object is positive or negative
      infinity.
    </summary><returns><c>true</c>
       if this object is positive or negative infinity; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.ExtendedFloat.IsNaN">

            <summary>Returns whether this object is a not-a-number value.
    </summary><returns><c>true</c>
       if this object is a not-a-number value; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="P:PeterO.ExtendedFloat.IsNegative">

            <summary>Gets a value indicating whether this object is negative,
            including negative zero.</summary><value><c>true</c> If this object is negative, including negative
            zero; otherwise, . <c>false</c>.</value>

</doc>
<doc name="M:PeterO.ExtendedFloat.IsNegativeInfinity">

            <summary>Returns whether this object is negative infinity.
    </summary><returns><c>true</c>
       if this object is negative infinity; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.ExtendedFloat.IsPositiveInfinity">

            <summary>Returns whether this object is positive infinity.
    </summary><returns><c>true</c>
       if this object is positive infinity; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.ExtendedFloat.IsQuietNaN">

            <summary>Gets a value indicating whether this object is a quiet not-a-number
      value.
    </summary><returns><c>true</c>
       if this object is a quiet not-a-number value; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.ExtendedFloat.IsSignalingNaN">

            <summary>Gets a value indicating whether this object is a signaling not-a-number
      value.
    </summary><returns><c>true</c>
       if this object is a signaling not-a-number value; otherwise, <c>false</c>
       .
    </returns>

</doc>
<doc name="P:PeterO.ExtendedFloat.Mantissa">

            <summary>Gets this object's un-scaled value.</summary><value>This object's un-scaled value. Will be negative if this
            object's value is negative (including a negative NaN).</value>

</doc>
<doc name="F:PeterO.ExtendedFloat.NaN">

            <summary>A not-a-number value.
    </summary>

</doc>
<doc name="F:PeterO.ExtendedFloat.NegativeInfinity">

            <summary>Negative infinity, less than any other number.
    </summary>

</doc>
<doc name="F:PeterO.ExtendedFloat.NegativeZero">

            <summary>Represents the number negative zero.
    </summary>

</doc>
<doc name="F:PeterO.ExtendedFloat.One">

            <summary>Represents the number 1.
    </summary>

</doc>
<doc name="F:PeterO.ExtendedFloat.PositiveInfinity">

            <summary>Positive infinity, greater than any other number.
    </summary>

</doc>
<doc name="P:PeterO.ExtendedFloat.Sign">

            <summary>Gets this value's sign: -1 if negative; 1 if positive; 0
            if zero.</summary><value>This value's sign: -1 if negative; 1 if positive; 0 if
            zero.</value>

</doc>
<doc name="F:PeterO.ExtendedFloat.SignalingNaN">

            <summary>A not-a-number value that signals an invalid operation flag when it's
      passed as an argument to any arithmetic operation in arbitrary-precision
      binary float.
    </summary>

</doc>
<doc name="F:PeterO.ExtendedFloat.Ten">

            <summary>Represents the number 10.
    </summary>

</doc>
<doc name="M:PeterO.ExtendedFloat.ToString">

            <summary>Converts this value to a string.
    </summary><returns>A string representation of this object. The value is converted to decimal
      and the decimal form of this number's value is returned.
    </returns>

</doc>
<doc name="P:PeterO.ExtendedFloat.UnsignedMantissa">

            <summary>Gets the absolute value of this object's un-scaled
            value.</summary><value>The absolute value of this object's un-scaled value.</value>

</doc>
<doc name="F:PeterO.ExtendedFloat.Zero">

            <summary>Represents the number 0.
    </summary>

</doc>
<doc name="T:PeterO.ExtendedRational">

            <summary><para><b>This class is largely obsolete. It will be replaced by a new version
          of this class in a different namespace/package and library, called
          <c>PeterO.Numbers.ERational</c>
           in the
          <a href='https://www.nuget.org/packages/PeterO.Numbers'>
            <c>PeterO.Numbers</c>
          </a>
           library (in .NET), or
          <c>com.upokecenter.numbers.ERational</c>
           in the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c>
          </a>
           artifact (in Java). This new class can be used in the
          <c>CBORObject.FromObject(object)</c>
           method (by including the new library in your code, among other
          things).</b>
      </para>
       Arbitrary-precision rational number. This class can't be inherited; this
      is a change in version 2.0 from previous versions, where the class was
      inadvertently left inheritable.
      <para><b>Thread safety:</b>
         Instances of this class are immutable, so they are inherently safe for
        use by multiple threads. Multiple instances of this object with the same
        properties are interchangeable, so they should not be compared using the
        "==" operator (which might only check if each side of the operator is
        the same instance).
      </para>
    </summary>

</doc>
<doc name="M:PeterO.ExtendedRational.#ctor(PeterO.BigInteger,PeterO.BigInteger)">

            <summary>Initializes a new instance of the <see cref='T:PeterO.ExtendedRational'/> class.</summary><param name='numerator'>An arbitrary-precision integer.</param><param name='denominator'>Another arbitrary-precision
            integer.</param><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='numerator'/> or <paramref name='denominator'/> is
            null.</exception>

</doc>
<doc name="M:PeterO.ExtendedRational.CompareTo(PeterO.ExtendedRational)">

            <summary>Compares this value to another.
    </summary><param name='other'>The parameter
      <paramref name='other'/>
       is an ExtendedRational object.
    </param><returns>Less than 0 if this value is less than, 0 if equal to, or greater than 0
      if greater than the other value.
    </returns>

</doc>
<doc name="M:PeterO.ExtendedRational.Create(PeterO.BigInteger,PeterO.BigInteger)">

            <summary>Creates a rational number with the given numerator and
            denominator.</summary><param name='numerator'>An arbitrary-precision integer.</param><param name='denominator'>Another arbitrary-precision
            integer.</param><returns>An arbitrary-precision rational number.</returns><exception cref='T:System.ArgumentNullException'>The parameter
            <paramref name='numerator'/> or <paramref name='denominator'/> is
            null.</exception>

</doc>
<doc name="M:PeterO.ExtendedRational.Create(System.Int32,System.Int32)">

            <summary>Creates a rational number with the given numerator and denominator.
    </summary><param name='numeratorSmall'>The parameter
      <paramref name='numeratorSmall'/>
       is a 32-bit signed integer.
    </param><param name='denominatorSmall'>The parameter
      <paramref name='denominatorSmall'/>
       is a 32-bit signed integer.
    </param><returns>An arbitrary-precision rational number.
    </returns>

</doc>
<doc name="P:PeterO.ExtendedRational.Denominator">

            <summary>Gets this object's denominator.</summary><value>This object's denominator.</value>

</doc>
<doc name="M:PeterO.ExtendedRational.Equals(PeterO.ExtendedRational)">

            <summary>Checks whether this and another value are equal.
    </summary><param name='other'>The parameter
      <paramref name='other'/>
       is an ExtendedRational object.
    </param><returns>Either
      <c>true</c>
       or
      <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.ExtendedRational.Equals(System.Object)">

            <summary>Checks whether this and another value are equal.
    </summary><param name='obj'>The parameter
      <paramref name='obj'/>
       is an arbitrary object.
    </param><returns>Either
      <c>true</c>
       or
      <c>false</c>
       .
    </returns>

</doc>
<doc name="M:PeterO.ExtendedRational.GetHashCode">

            <summary>Calculates the hash code for this object. No application or process IDs
      are used in the hash code calculation.
    </summary><returns>A 32-bit signed integer.
    </returns>

</doc>
<doc name="P:PeterO.ExtendedRational.IsFinite">

            <summary>Gets a value indicating whether this object is finite (not
            infinity or NaN).</summary><value><c>true</c> If this object is finite (not infinity or NaN);
            otherwise, . <c>false</c>.</value>

</doc>
<doc name="P:PeterO.ExtendedRational.IsNegative">

            <summary>Gets a value indicating whether this object's value is
            negative (including negative zero).</summary><value><c>true</c> If this object's value is negative; otherwise, .
            <c>false</c>.</value>

</doc>
<doc name="P:PeterO.ExtendedRational.IsZero">

            <summary>Gets a value indicating whether this object's value equals
            0.</summary><value><c>true</c> If this object's value equals 0; otherwise, .
            <c>false</c>.</value>

</doc>
<doc name="F:PeterO.ExtendedRational.NaN">

            <summary>A not-a-number value.
    </summary>

</doc>
<doc name="F:PeterO.ExtendedRational.NegativeInfinity">

            <summary>Negative infinity, less than any other number.
    </summary>

</doc>
<doc name="F:PeterO.ExtendedRational.NegativeZero">

            <summary>A rational number for negative zero.
    </summary>

</doc>
<doc name="P:PeterO.ExtendedRational.Numerator">

            <summary>Gets this object's numerator.</summary><value>This object's numerator. If this object is a not-a-number
            value, returns the diagnostic information (which will be negative
            if this object is negative).</value>

</doc>
<doc name="F:PeterO.ExtendedRational.One">

            <summary>The rational number one.
    </summary>

</doc>
<doc name="F:PeterO.ExtendedRational.PositiveInfinity">

            <summary>Positive infinity, greater than any other number.
    </summary>

</doc>
<doc name="P:PeterO.ExtendedRational.Sign">

            <summary>Gets the sign of this rational number.
    </summary><value>Zero if this value is zero or negative zero; -1 if this value is less
      than 0; and 1 if this value is greater than 0.
    </value>

</doc>
<doc name="F:PeterO.ExtendedRational.SignalingNaN">

            <summary>A signaling not-a-number value.
    </summary>

</doc>
<doc name="F:PeterO.ExtendedRational.Ten">

            <summary>The rational number ten.
    </summary>

</doc>
<doc name="M:PeterO.ExtendedRational.ToString">

            <summary>Converts this object to a text string.
    </summary><returns>A string representation of this object. The result can be Infinity, NaN,
      or sNaN (with a minus sign before it for negative values), or a number of
      the following form: [-]numerator/denominator.
    </returns>

</doc>
<doc name="P:PeterO.ExtendedRational.UnsignedNumerator">

            <summary>Gets this object's numerator with the sign
            removed.</summary><value>This object's numerator. If this object is a not-a-number
            value, returns the diagnostic information.</value>

</doc>
<doc name="F:PeterO.ExtendedRational.Zero">

            <summary>A rational number for zero.
    </summary>

</doc>
<doc name="T:PeterO.PrecisionContext">

            <summary>A precision context.
    </summary>

</doc>
<doc name="M:PeterO.PrecisionContext.#ctor(System.Int32,PeterO.Rounding,System.Int32,System.Int32,System.Boolean)">

            <summary>Initializes a new instance of the <see cref='T:PeterO.PrecisionContext'/> class. HasFlags will be set to false.
    </summary><param name='precision'>The maximum number of digits a number can have, or 0 for an unlimited
      number of digits.
    </param><param name='rounding'>The rounding mode to use when a number can't fit the given precision.
    </param><param name='exponentMinSmall'>The minimum exponent.
    </param><param name='exponentMaxSmall'>The maximum exponent.
    </param><param name='clampNormalExponents'>Whether to clamp a number's significand to the given maximum precision
      (if it isn't zero) while remaining within the exponent range.
    </param>

</doc>
<doc name="M:PeterO.PrecisionContext.ToString">

            <summary>Gets a string representation of this object. Note that the format is not
      intended to be parsed and may change at any time.
    </summary><returns>A string representation of this object.
    </returns>

</doc>
<doc name="T:PeterO.Rdf.URIUtility">
<summary>Contains utility methods for processing Uniform Resource Identifiers
      (URIs) and Internationalized Resource Identifiers (IRIs) under RFC3986 and
      RFC3987, respectively. In the following documentation, URIs and IRIs
      include URI references and IRI references, for convenience.
    </summary>
</doc>
<doc name="T:PeterO.Rdf.URIUtility.ParseMode">
<summary>Specifies whether certain characters are allowed when parsing IRIs and
      URIs.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.IRILenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Even with this mode, strings with unpaired surrogate code points are
      considered invalid.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.IRIStrict">
<summary>The rules follow the syntax for parsing IRIs. In particular, many code
      points outside the Basic Latin range (U+0000 to U+007F) are allowed.
      Strings with unpaired surrogate code points are considered invalid.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.IRISurrogateLenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Unpaired surrogate code points are treated as though they were replacement
      characters instead for the purposes of these rules, so that strings with
      those code points are not considered invalid strings.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.URILenient">
<summary>The rules only check for the appropriate delimiters when splitting the
      path, without checking if all the characters in each component are valid.
      Code points outside the Basic Latin range (U+0000 to U+007F) are not
      allowed.
    </summary>
</doc>
<doc name="F:PeterO.Rdf.URIUtility.ParseMode.URIStrict">
<summary>The rules follow the syntax for parsing IRIs, except that code points
      outside the Basic Latin range (U+0000 to U+007F) are not allowed.
    </summary>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.escapeURI(System.String,System.Int32)">
<returns>A string possibly containing escaped characters, or null if s is null.
    </returns>
    <summary>Escapes characters that cannot appear in URIs or IRIs. The function is
      idempotent; that is, calling the function again on the result with the
      same mode doesn't change the result.
    </summary>
    <param name='s'>A string to escape.
    </param>
    <param name='mode'>The parameter
      <paramref name='mode'/>
       is a 32-bit signed integer.
    </param>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.hasScheme(System.String)">
<summary>Determines whether the string is a valid IRI with a scheme component. This
      can be used to check for relative IRI references.
      <para>The following cases return true:
      </para>
      <code>xx-x:mm example:/ww
      </code>
       The following cases return false:
      <code>x@y:/z /x/y/z example.xyz
      </code>
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c>
       if the string is a valid IRI with a scheme component; otherwise, <c>false</c>
       .
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.hasSchemeForURI(System.String)">
<summary>Determines whether the string is a valid URI with a scheme component. This
      can be used to check for relative URI references. The following cases
      return true:
      <code>http://example/z xx-x:mm example:/ww
      </code>
       The following cases return false:
      <code>x@y:/z /x/y/z example.xyz
      </code>
    </summary>
    <param name='refValue'>A string representing an IRI to check.
    </param>
    <returns><c>true</c>
       if the string is a valid URI with a scheme component; otherwise, <c>false</c>
       .
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.isValidCurieReference(System.String,System.Int32,System.Int32)">
<summary>Determines whether the substring is a valid CURIE reference under RDFA
      1.1. (The CURIE reference is the part after the colon.).
    </summary>
    <param name='s'>A string containing a CURIE reference. Can be null.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The number of elements in the desired portion of "s" (but not more than
      "s" 's length).
    </param>
    <returns><c>true</c>
       if the substring is a valid CURIE reference under RDFA 1; otherwise, <c>false</c>
       . Returns false if
      <paramref name='s'/>
       is null.
    </returns>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       's length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.relativeResolve(System.String,System.String)">
<summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c>
       .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c>
       .
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If base is null or is not a valid IRI,
      returns refValue. Example: http://example.com/my/path/dir/file.txt.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.relativeResolve(System.String,System.String,PeterO.Rdf.URIUtility.ParseMode)">
<summary>Resolves a URI or IRI relative to another URI or IRI.
    </summary>
    <param name='refValue'>A string representing a URI or IRI reference. Example:
      <c>dir/file.txt</c>
       .
    </param>
    <param name='baseURI'>A string representing an absolute URI reference. Example:
      <c>http://example.com/my/path/</c>
       .
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>The resolved IRI, or null if
      <paramref name='refValue'/>
       is null or is not a valid IRI. If base is null or is not a valid IRI,
      returns refValue.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.splitIRI(System.String)">
<summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI reference is syntactically valid, splits the string
      into its components and returns an array containing the indices into the
      components.
      <returns>If the string is a valid IRI reference, returns an array of 10 integers.
        Each of the five pairs corresponds to the start and end index of the
        IRI's scheme, authority, path, query, or fragment identifier,
        respectively. If a component is absent, both indices in that pair will
        be -1. If the string is null or is not a valid IRI, returns null.
      </returns>
    </summary>
    <param name='s'>A string that contains an IRI.
    </param>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.splitIRI(System.String,PeterO.Rdf.URIUtility.ParseMode)">
<summary>Parses an Internationalized Resource Identifier (IRI) reference under
      RFC3987. If the IRI is syntactically valid, splits the string into its
      components and returns an array containing the indices into the
      components.
    </summary>
    <param name='s'>A string representing an IRI. Can be null.
    </param>
    <param name='parseMode'>The parameter
      <paramref name='parseMode'/>
       is a ParseMode object.
    </param>
    <returns>If the string is a valid IRI reference, returns an array of 10 integers.
      Each of the five pairs corresponds to the start and end index of the IRI's
      scheme, authority, path, query, or fragment identifier, respectively. If a
      component is absent, both indices in that pair will be -1. If the string
      is null or is not a valid IRI, returns null.
    </returns>
</doc>
<doc name="M:PeterO.Rdf.URIUtility.splitIRI(System.String,System.Int32,System.Int32,PeterO.Rdf.URIUtility.ParseMode)">
<summary>Parses a substring that represents an Internationalized Resource
      Identifier (IRI) under RFC3987. If the IRI is syntactically valid, splits
      the string into its components and returns an array containing the indices
      into the components.
    </summary>
    <param name='s'>A string that contains an IRI.
    </param>
    <param name='offset'>A zero-based index showing where the desired portion of "s" begins.
    </param>
    <param name='length'>The length of the desired portion of "s" (but not more than "s" 's
      length).
    </param>
    <param name='parseMode'>Parse mode that specifies whether certain characters are allowed when
      parsing IRIs and URIs.
    </param>
    <returns>If the string is a valid IRI, returns an array of 10 integers. Each of the
      five pairs corresponds to the start and end index of the IRI's scheme,
      authority, path, query, or fragment identifier, respectively. If a
      component is absent, both indices in that pair will be -1 (an index won't
      be less than 0 in any other case). If the string is null or is not a valid
      IRI, returns null.
    </returns>
    <exception cref='T:System.ArgumentException'>Either
      <paramref name='offset'/>
       or
      <paramref name='length'/>
       is less than 0 or greater than
      <paramref name='s'/>
       's length, or
      <paramref name='s'/>
       's length minus
      <paramref name='offset'/>
       is less than
      <paramref name='length'/>
       .
    </exception>
    <exception cref='T:System.ArgumentNullException'>The parameter
      <paramref name='s'/>
       is null.
    </exception>
</doc>
<doc name="T:PeterO.Rounding">

            <summary><para><b>This class is obsolete. It will be replaced by a new version of this
          class in a different namespace/package and library, called
          <c>PeterO.Numbers.ERounding</c>
           in the
          <c>PeterO.ERounding</c>
           library (in .NET), or
          <c>com.upokecenter.numbers.EFloat</c>
           in the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c>
          </a>
           artifact (in Java).</b>
      </para>
       Specifies the mode to use when "shortening" numbers that otherwise can't
      fit a given number of digits, so that the shortened number has about the
      same value. This "shortening" is known as rounding.
    </summary>

</doc>
<doc name="F:PeterO.Rounding.Ceiling">

            <summary>If there is a fractional part, the number is rounded to the highest
      representable number that's closest to it.
    </summary>

</doc>
<doc name="F:PeterO.Rounding.Down">

            <summary>The fractional part is discarded (the number is truncated).
    </summary>

</doc>
<doc name="F:PeterO.Rounding.Floor">

            <summary>If there is a fractional part, the number is rounded to the lowest
      representable number that's closest to it.
    </summary>

</doc>
<doc name="F:PeterO.Rounding.HalfDown">

            <summary>Rounded to the nearest number; if the fractional part is exactly half, it
      is discarded.
    </summary>

</doc>
<doc name="F:PeterO.Rounding.HalfEven">

            <summary>Rounded to the nearest number; if the fractional part is exactly half,
      the number is rounded to the closest representable number that is even.
      This is sometimes also known as "banker's rounding".
    </summary>

</doc>
<doc name="F:PeterO.Rounding.HalfUp">

            <summary>Rounded to the nearest number; if the fractional part is exactly half,
      the number is rounded to the closest representable number away from zero.
      This is the most familiar rounding mode for many people.
    </summary>

</doc>
<doc name="F:PeterO.Rounding.Odd">

            <summary>If there is a fractional part and the whole number part is even, the
      number is rounded to the closest representable odd number away from zero.
    </summary>

</doc>
<doc name="F:PeterO.Rounding.OddOrZeroFiveUp">

            <summary>For binary floating point numbers, this is the same as Odd. For other
      bases (including decimal numbers), this is the same as ZeroFiveUp. This
      rounding mode is useful for rounding intermediate results at a slightly
      higher precision (at least 2 bits more for binary) than the final
      precision.
    </summary>

</doc>
<doc name="F:PeterO.Rounding.Unnecessary">

            <summary>Indicates that rounding will not be used. If rounding is required, the
      rounding operation will report an error.
    </summary>

</doc>
<doc name="F:PeterO.Rounding.Up">

            <summary>If there is a fractional part, the number is rounded to the closest
      representable number away from zero.
    </summary>

</doc>
<doc name="F:PeterO.Rounding.ZeroFiveUp">

            <summary>If there is a fractional part and if the last digit before rounding is 0
      or half the radix, the number is rounded to the closest representable
      number away from zero; otherwise the fractional part is discarded. In
      overflow, the fractional part is always discarded.
    </summary>

</doc>
<doc name="T:PeterO.TrapException">

            <summary><para><b>This class is obsolete. It will be replaced by a new version of this
          class in a different namespace/package and library, called
          <c>PeterO.Numbers.ETrapException</c>
           in the
          <a href='https://www.nuget.org/packages/PeterO.Numbers'>
            <c>PeterO.Numbers</c>
          </a>
           library (in .NET), or
          <c>com.upokecenter.numbers.ETrapException</c>
           in the
          <a href='https://github.com/peteroupc/numbers-java'>
            <c>com.github.peteroupc/numbers</c>
          </a>
           artifact (in Java).</b>
      </para>
       Exception thrown for arithmetic trap errors.
    </summary>

</doc>
<doc name="M:PeterO.TrapException.#ctor(System.Int32,PeterO.PrecisionContext,System.Object)">

            <summary>Initializes a new instance of the <see cref='T:PeterO.TrapException'/> class.
    </summary><param name='flag'>A flag that specifies the kind of error (PrecisionContext.FlagXXX). This
      will only be one flag, such as FlagInexact or FlagSubnormal.
    </param><param name='ctx'>A context object for arbitrary-precision arithmetic settings.
    </param><param name='result'>The desired result of the operation that caused the trap, such as an
      <c>ExtendedDecimal</c>
       or
      <c>ExtendedFloat</c>
       .
    </param>

</doc>
<doc name="P:PeterO.TrapException.Context">

            <summary>Gets the precision context used during the operation that triggered the
      trap. May be null.
    </summary><value>The precision context used during the operation that triggered the trap.
      May be null.
    </value>

</doc>
<doc name="P:PeterO.TrapException.Error">

            <summary>Gets the flag that specifies the kind of error
      (PrecisionContext.FlagXXX). This will only be one flag, such as
      FlagInexact or FlagSubnormal.
    </summary><value>The flag that specifies the kind of error (PrecisionContext.FlagXXX).
      This will only be one flag, such as FlagInexact or FlagSubnormal.
    </value>

</doc>
<doc name="P:PeterO.TrapException.Result">

            <summary>Gets the defined result of the operation that caused the trap.
    </summary><value>The defined result of the operation that caused the trap.
    </value>

</doc>
</docs>
